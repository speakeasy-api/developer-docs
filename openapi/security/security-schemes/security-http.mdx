---
title: HTTP Basic in OpenAPI
description: "Implement Basic authentication using Security Schemes in your OpenAPI specification for better security, developer experience, and seamless integration."
---

import { Table } from "@/mdx/components";

# HTTP Security Scheme in OpenAPI

The `http` security scheme is one of the most commonly used schemes because it covers anything using the HTTP header `Authorization`. This is a big list, including auth schemes like HTTP Basic, HTTP Digest, and Bearer. The full list of supports auth schemes for `type: http` is outsourced to the [IANA HTTP Authentication Scheme Registry](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml).

Of that list, the most likely to be used for a modern API are:

- [Bearer](#http-bearer)
- [Basic](#http-basic)
- [Digest](#http-digest)

## HTTP Bearer

The Bearer security scheme allows passing a token, which could be a JWT, API token, access token, or anything else.

```http
GET /secrets

Authorization: Bearer <token>
```

The Bearer security scheme is generally used for short-lived tokens granted to your API users through an additional login mechanism. Using a JWT allows for storing additional metadata within the token, which can be helpful for some use cases, such as storing scopes for permissions models.

The fields for a Bearer security scheme are as follows:

<Table
  data={[
    { field: "`type`", type: "String", required: "✅", description: "`http`" },
    {
      field: "`description`",
      type: "String",
      required: "",
      description:
        "Human-readable information. This may contain [CommonMark syntax](https://spec.commonmark.org/) to provide a rich description.",
    },
    {
      field: "`scheme`",
      type: "String",
      required: "✅",
      description: "`bearer`",
    },
    {
      field: "`bearerFormat`",
      type: "String",
      required: "",
      description:
        "A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.",
    },
    {
      field: "`x-*`",
      type: "[Extensions](/openapi/extensions)",
      required: "",
      description:
        "Any number of extension fields can be added to the security scheme object to be used by tooling and vendors.",
    },
  ]}
  columns={[
    { key: "field", header: "Field" },
    { key: "type", header: "Type" },
    { key: "required", header: "Required" },
    { key: "description", header: "Description" },
  ]}
/>

So for example, a JWT token might look like this:

```yaml
components:
  securitySchemes:
    auth:
      type: http
      scheme: bearer
      bearerFormat: JWT
security:
  - auth: []
```

## HTTP Basic

The Basic security scheme is a simple authentication mechanism baked into the HTTP protocol that supports sending an `Authorization` header containing a base64 encoded username and password.

```http
GET /secrets

Authorization: Basic dXNlcjpwYXNzd29yZA==
```

Basic is relatively simple mechanism to get started with, but risks leaking easy-to-decode passwords if used incorrectly. The example above is simply `base64("user:password")`, but can fool some developers into thinking its actually encrypted or secret.

Much like API keys, another issue with Basic is that it's generally working with long-lived credentials, and if intercepted, these can be used by malicious actors until the credentials are revoked or expire.

For these reasons it is generally best to avoid HTTP Basic.

Since all APIs need to be accurately described (warts and all), here's how to describe HTTP Basic in OpenAPI:

<Table
  data={[
    { field: "`type`", type: "String", required: "✅", description: "`http`" },
    {
      field: "`description`",
      type: "String",
      required: "",
      description:
        "Human-readable information. This may contain [CommonMark syntax](https://spec.commonmark.org/) to provide a rich description.",
    },
    {
      field: "`scheme`",
      type: "String",
      required: "✅",
      description: "`basic`",
    },
    {
      field: "`x-*`",
      type: "[Extensions](/openapi/extensions)",
      required: "",
      description:
        "Any number of extension fields can be added to the security scheme object to be used by tooling and vendors.",
    },
  ]}
  columns={[
    { key: "field", header: "Field" },
    { key: "type", header: "Type" },
    { key: "required", header: "Required" },
    { key: "description", header: "Description" }
  ]}
/>

For example: 

```yaml
components:
  securitySchemes:
    auth:
      type: http
      scheme: basic
security:
  - auth: []
```

The description field can be used to warn developers about the risks of using Basic authentication, and to encourage them to use more secure alternatives like Bearer tokens or OAuth2.

```yaml
components:
  securitySchemes:
    auth:
      type: http
      scheme: basic
      description: |
        **Warning:** Basic authentication sends credentials in an easily decodable format, so this
        should only be used over HTTPS. Instead of using your password please only use a short lived access token
        which can be obtained from <https://example.com/tokens>.
```

## HTTP Digest

The Digest security scheme is a more secure alternative to Basic authentication. Instead of sending the username and password in plain text, Digest authentication uses a challenge-response mechanism that hashes credentials with a nonce provided by the server. This helps protect against replay attacks and credential interception.

A typical Digest authentication request looks like this:

```http
GET /secrets

Authorization: Digest username="user",
  realm="example",
  nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
  uri="/secrets",
  response="6629fae49393a05397450978507c4ef1",
  opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

The fields for a Digest security scheme in OpenAPI are as follows:

<Table
  data={[
    { field: "`type`", type: "String", required: "✅", description: "`http`" },
    {
      field: "`description`",
      type: "String",
      required: "",
      description:
        "Human-readable information. This may contain [CommonMark syntax](https://spec.commonmark.org/) to provide a rich description.",
    },
    {
      field: "`scheme`",
      type: "String",
      required: "✅",
      description: "`digest`",
    },
    {
      field: "`x-*`",
      type: "[Extensions](/openapi/extensions)",
      required: "",
      description:
        "Any number of extension fields can be added to the security scheme object to be used by tooling and vendors.",
    },
  ]}
  columns={[
    { key: "field", header: "Field" },
    { key: "type", header: "Type" },
    { key: "required", header: "Required" },
    { key: "description", header: "Description" },
  ]}
/>

For example:

```yaml
components:
  securitySchemes:
    digestAuth:
      type: http
      scheme: digest
security:
  - digestAuth: []
```

## Overlap with other security schemes

The HTTP security scheme overlaps with a few other more specific schemes.

The [API Key](./security-api-key.mdx) security scheme is better suited for non-standard API keys using custom headers like `Acme-API-Key`, whereas HTTP security schemes are specifically designed for HTTP-based authentication methods using `Authorization` header.

There is also some overlap with [OAuth2](./security-oauth2.mdx) and [OpenID Connect](./security-openid.mdx) security schemes. These may use bearer tokens, and they may use the JWT format, but they are more complex and involve additional flows and endpoints. The `oauth2` and `openidConnect` security schemes are better suited for any APIs using the OAuth 2.0 and OpenID Connect protocols than trying to cover it with the `http` security scheme.

### Unauthorized Response

As well as describing the security requirements, it also helps to describe what will happen when those requirements are not met. The 401 Unauthorized response can be returned for requests with missing security credentials, showing what the client can expect to see if this happens. This response includes the `WWW-Authenticate` header, which you may want to mention. As with other generic responses, the 401 response can be defined as a component in the `responses` section, and referenced with `$ref` to avoid repetition.

```yaml
paths:
  /drinks:
    get:
      # ...
      responses:
        # ...
        '401':
          $ref: '#/components/responses/HttpErrorUnauthorized'
    post:
      # ...
      responses:
        # ...
        '401':
          $ref: '#/components/responses/HttpErrorUnauthorized'

components:
  responses:
    HttpErrorUnauthorized:
      description: Unauthorized
      headers:
        WWW_Authenticate:
          schema:
            type: string
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
```

Learn more about describing [responses](../../responses.mdx).

## Forbidden Response

The 403 Forbidden response can be returned for requests that are authenticated but not authorized to access the resource. This response can also include the `WWW-Authenticate` header, but it is not required. 

As with the 401 response, the 403 response can be defined as a component in the `responses` section, and referenced with `$ref` to avoid repetition. This error is using the HTTP Problem Details format, which is a standard way to provide more information about the error.

```yaml
paths:
  /drinks:
    get:
      # ...
      responses:
        # ...
        '403':
          $ref: '#/components/responses/HttpErrorForbidden'
    post:
      # ...
      responses:
        # ...
        '403':
          $ref: '#/components/responses/HttpErrorForbidden'
components:
  responses:
    HttpErrorForbidden:
      description: Forbidden
      headers:
        WWW_Authenticate:
          type: string
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetails'
```
