---
title: How to generate an OpenAPI document with FastAPI
description: "Creating an OpenAPI document with FastAPI and using it to generate SDKs with Speakeasy."
---

import { YouTube, Callout, Spotlight } from "@/mdx/components";

# How to generate an OpenAPI document with FastAPI

<div className="mt-10 flex items-center justify-center">
  <YouTube videoId="86hiib_OA4c" />
</div>

Many developers start their API development with FastAPI, and with good reason. FastAPI has rapidly gained traction in the Python community for its excellent performance, intuitive design, and flexibility. It enables developers to craft API solutions that not only run fast but also meet their users' unique needs.

FastAPI is great for building your core API, but you'll want to layer on SDKs and docs to provide your users with easy integration. For that, you'll want an OpenAPI file.

The good news is that FastAPI provides you with an OpenAPI file out of the box. The less good news is that you'll need some tweaking to get the OpenAPI document to a level where it becomes usable with other tooling.

This article will show you how to improve the default OpenAPI document generation to make the most of the generated schema.

## Generating an OpenAPI document with FastAPI

Understanding how FastAPI generates OpenAPI schemas can help you make more informed decisions when you customize your FastAPI setup.

The process is fairly straightforward: FastAPI builds the OpenAPI schema based on the routes and models you've defined in your application. For every route in your FastAPI application, FastAPI adds an operation to the OpenAPI schema. For every model used in these routes, FastAPI adds a schema definition. The request and response bodies, parameters, and headers all draw from these schema definitions.

While this process works well out of the box, FastAPI also offers several customization options that can change the generated OpenAPI schema. We'll cover some of these options in the following sections.

## Our FastAPI example app: APItizing Burgers

Let's get this out of the way: The name came in a daydream shortly before lunchtime.

To guide us through this journey, we'll use a simple example FastAPI application: the "APItizing Burgers" burger shop API. This API includes two models, `Burger` and `Order`, and provides basic CRUD operations for managing burgers and orders at our hypothetical burger shop. Additionally, we have a webhook defined for order status events.

We'll look at how we optimized this FastAPI application and refined our models and routes so that the generated OpenAPI document is intuitive and easy to use. We will also explore how we can use this schema to generate SDKs using Speakeasy. The source code for our example API is available in the [apitizing-burgers](https://github.com/speakeasy-api/apitizing-burgers) repository.

The repository consists of two directories: `app` and `sdk`.

The `app` directory contains only our FastAPI server definition: `app/main.py`. This is where we'll look at what we customized.

The `sdk` directory and the two OpenAPI documents, `openapi.yaml` and `openapi.json`, are generated by running `gen.sh` in the root of the project.

Join us as we dive into FastAPI customization and discover how these tweaks can streamline your SDK generation process.

<Callout title="Warning" type="warning">
  When using Pydantic to define models, a known issue is that the serialization
  of `datetime` objects is not timezone-aware. This will cause a mismatch with
  the OpenAPI format `date-time`, which requires RFC 3339 date-time strings with
  timezones included. Consider using
  [`AwareDatetime`](https://docs.pydantic.dev/2.5/api/types/#pydantic.types.AwareDatetime)
  fields in Pydantic models to enable the appropriate
  [validation](https://docs.pydantic.dev/latest/errors/validation_errors/#timezone_aware)
  and ensure your SDK behavior matches the response definition from your server.
</Callout>

## Basic FastAPI setup

Let's get started with the basics â€“ some things you probably do already.

These straightforward examples are trivial but will help you better understand the three steps in the automation pipeline: How FastAPI setup influences OpenAPI documents, which, in turn, influences SDK code.

<Spotlight>

#### !!steps ServerConfig

This may seem obvious, but while first working with FastAPI in development, the generated docs, development server, and API operations all work out of the box without the need to manually specify your server address.

However, when generating SDKs, your OpenAPI document needs to list servers.

In our `app/main.py`, we added our local server as shown.

```python ! servers.py
!from ./assets/fastapi/servers.py.txt
```

#### !!steps GeneratedYaml

This leads to the following generated output in `openapi.yaml`.

```yaml ! servers_openapi.yaml
!from ./assets/fastapi/servers_openapi.yaml
```

#### !!steps AppInfo

In our `app/main.py`, if we have the following.

```python ! info.py
!from ./assets/fastapi/info.py.txt
```

#### !!steps InfoYaml

FastAPI generates the following YAML in our `openapi.yaml` file.

```yaml ! info.yaml
!from ./assets/fastapi/openapi_info.yaml
```

#### !!steps RouteCustomizations

With the basics out of the way, let's look at a few more substantial recommendations.

```yaml ! route-customizations.yaml
# Route-level customizations can significantly enhance the usability of your API
```

#### !!steps TypedResponses

When developers use your generated SDK, they may wish to see what all the possible responses for an API call could be.

With FastAPI, you can add additional responses to each route by specifying a response type.

In our `app/main.py`, we added this abbreviated code.

```python ! responses.py
!from ./assets/fastapi/responses.py.txt
```

#### !!steps ResponseSchema

FastAPI adds a schema for our specific error message to `openapi.yaml`.

```yaml ! response_schema.yaml
!from ./assets/fastapi/response_schema.yaml
```

#### !!steps OperationTags

As your API develops and grows bigger, you're likely to split it into separate files. FastAPI [provides conveniences](https://fastapi.tiangolo.com/tutorial/bigger-applications/) to help reduce boilerplate and repetition when splitting an API into multiple modules.

While this separation may reduce cognitive overhead while you're working in particular sections of the API code, it doesn't mean similar groups are automatically created in your documentation and SDK code.

We recommend you add tags to all operations in FastAPI, whether you're building a big application or only have a handful of operations, so that operations can be grouped by tag in generated SDK code and documentation.

```yaml ! operation-tags.yaml
# Tags help organize operations into logical groups
tags:
  - name: burger
  - name: order
```

#### !!steps TagsToOperations

The most straightforward way to add tags is to edit each operation and add a list of tags. This example highlights the tags list.

```python ! tags_operation.py
!from ./assets/fastapi/tags_operation.py.txt
```

#### !!steps TagMetadata

You can add metadata to your tags to further improve the developer experience.

FastAPI accepts a parameter called `openapi_tags`, which we can use to add metadata, such as a description and a list of external documentation links.

Here's how to add metadata to tags.

```python ! tag_metadata.py
!from ./assets/fastapi/tag_metadata.py.txt
```

#### !!steps TagsInOpenAPI

When we add metadata to tags, FastAPI adds a top-level `tags` section to our OpenAPI document.

```yaml ! tags.yaml
!from ./assets/fastapi/tags_openapi.yaml
```

#### !!steps PathTags

Each tagged path in our OpenAPI document also gets a list of tags.

```yaml ! paths.yaml
!from ./assets/fastapi/paths_tags.yaml
```


#### !!steps OperationIDCustomization

When FastAPI outputs an OpenAPI document, it generates a unique OpenAPI `operationId` for each path. By default, this unique ID is generated by the FastAPI `generate_unique_id` function.

```python ! operation_id.py
!from ./assets/fastapi/operation_id_default.py.txt
```

#### !!steps CustomizationOptions

This can often lead to cumbersome and unintuitive names. To improve usability, we have two methods of customizing these generated strings.

```yaml ! customization-options.yaml
# There are multiple ways to customize operation IDs
# 1. Using a custom generate_unique_id_function
# 2. Specifying operation_id per operation
```


#### !!steps CustomUniqueIDFunction

The preferred method is to use a custom function when you generate unique IDs for paths.

The example below is an illustrative function that doesn't generate guaranteed-unique IDs and doesn't handle method names without an underscore. However, it demonstrates how you can add a function that generates IDs based on an operation's method name.

```python ! custom_id.py
!from ./assets/fastapi/custom_id_function.py.txt
```

#### !!steps OperationIDPerRoute

With FastAPI, you can specify the `operationId` per operation. For our example, we'll add a new parameter called `operation_id` to the operation decorator.

```python ! operation_id_route.py
!from ./assets/fastapi/operation_id_per_route.py.txt
```

#### !!steps WebhooksRealtime

Starting with OpenAPI version 3.1.0, it is possible to specify webhooks for your application in OpenAPI.

Here's how to add a webhook to FastAPI:

```python ! webhook.py
!from ./assets/fastapi/webhook.py.txt
```

#### !!steps WebhooksGenerated

FastAPI generates the following top-level `webhooks` section in `openapi.yaml`.

```yaml ! webhook.yaml
!from ./assets/fastapi/webhook_openapi.yaml
```

#### !!steps SpeakeasyIntegration

Now that we have a customized OpenAPI document, we can use Speakeasy to generate SDKs based on it. Let's take a look at how the information we detailed in the OpenAPI document affects how Speakeasy generates SDKs.

```yaml ! speakeasy-integration.yaml
# Speakeasy uses the OpenAPI document to generate SDKs
# The customizations we've made influence how the SDK code is generated
```

#### !!steps ServerInfoOutput

After we added our local server information, this is how it generates in the `openapi.yaml` file.

```yaml ! servers_output.yaml
!from ./assets/fastapi/servers_output.yaml
```

#### !!steps SDKConfiguration

After Speakeasy generates the SDK, this leads to the following abbreviated code in `sdk/src/openapi/sdkconfiguration.py`.

```python ! sdk_config.py
!from ./assets/fastapi/sdk_configuration.py.txt
```

#### !!steps ServerDetails

You'll find calls to `SDKConfiguration.get_server_details()` when the SDK builds API URLs.

```python ! server_details.py
!from ./assets/fastapi/server_details.py.txt
```

#### !!steps TitleAndDescription

Speakeasy uses the title, summary, and descriptions we provided earlier to add helpful text to the generated SDK documentation, including comments in the SDK code. For example, in `sdk/src/sdk/sdk.py`.

```python ! sdk_class.py
!from ./assets/fastapi/sdk_class.py.txt
```

#### !!steps VersionInfo

Speakeasy adds the version to the `SDKConfiguration` in `sdk/src/openapi/sdkconfiguration.py`. It also uses this version to construct the user agent (`user_agent`), which contains the version of the SDK, the version of the Speakeasy generator build, and the version of the OpenAPI documentation.

```python ! sdk_version.py
!from ./assets/fastapi/sdk_config_version.py.txt
```

#### !!steps UserAgentHeader

When users call your API using the generated SDK, the `user_agent` from `SDKConfiguration` is automatically added to the `user-agent` header. The `_build_request_with_client` method in `BaseSDK` constructs the HTTP request and sets the header using `headers[user_agent_header] = self.sdk_configuration.user_agent`.

```python ! headers.py
!from ./assets/fastapi/headers.py.txt
```

#### !!steps OperationIDIssues

The unique `operation_id` generated by FastAPI does not translate well into an SDK. We need to customize the unique `operation_id` that FastAPI generates for better readability.

For instance, in the operation that returns a burger by `burger_id`, the default unique ID would be `read_burger_burger__burger_id__get`. This makes its way into SDK code, leading to class names such as `ReadBurgerBurgerBurgerIDGetRequest` or function names like `read_burger_burger_burger_id_get`.

Here's a usage example after generating an SDK without customizing the `operationId`.

```python ! without_custom.py
!from ./assets/fastapi/without_custom_id.py.txt
```

#### !!steps WithCustomID

However, after using the custom function `generate_unique_id` we defined previously, the `read_burger` operation gets a much friendlier operation ID: `readBurger`. And the usage example becomes much easier to read.

```python ! with_custom.py
!from ./assets/fastapi/with_custom_id.py.txt
```

#### !!steps SpeakeasyNameOverride

In addition to the two methods described earlier for customizing the `operation_id`, there is a third way. We can add the top-level `x-speakeasy-name-override` extension to our OpenAPI document, allowing Speakeasy to override these generated names when it generates SDK code.

To add this extension, follow the Speakeasy guide on [changing method names](/docs/customize-sdks/methods).

```yaml ! name-override.yaml
# Example of x-speakeasy-name-override extension
x-speakeasy-name-override:
  operations:
    readBurger: getBurger
    createBurger: addBurger
```

#### !!steps SpeakeasyRetries

Speakeasy can generate SDKs that follow custom rules for retrying failed requests. For instance, if your server fails to return a response within a specified time, you may want your users to retry their request without clobbering your server.

To add retries to SDKs generated by Speakeasy, add a top-level `x-speakeasy-retries` schema to your OpenAPI document. You can also override the retry strategy per operation by adding `x-speakeasy-retries` to each operation.

```yaml ! speakeasy-retries.yaml
# Speakeasy retries can be configured with a top-level extension
x-speakeasy-retries:
  strategy: backoff
  statusCodes: [5XX]
  retryConnectionErrors: true
```

#### !!steps GlobalRetries

To add global retries, we need to customize the schema generated by the FastAPI `get_openapi` function.

```python ! custom_openapi.py
!from ./assets/fastapi/custom_openapi.py.txt
```

Keep in mind, you'll need to add this customization _after_ declaring your operation routes.

#### !!steps RetriesYaml

This change adds the following top-level section to `openapi.yaml`.

```yaml ! retries.yaml
!from ./assets/fastapi/retries_openapi.yaml
```

#### !!steps PerRequestRetries

To add `x-speakeasy-retries` to a single operation, update the operation and add the `openapi_extra` parameter as follows.

```python ! per_request_retries.py
!from ./assets/fastapi/per_request_retries.py.txt
```

#### !!steps AuthSecurity

FastAPI supports several authentication mechanisms that can be easily integrated into your API.

The example below demonstrates adding an API key authentication scheme to the `/burger/` endpoint of our API. We use the `APIKeyHeader` dependency to validate the API key passed in the `Authorization` header.

```python ! api_key_security.py
!from ./assets/fastapi/api_key_security.py.txt
```

#### !!steps APIKeyUsage

We can pass a `key` parameter to the `list_burgers` function, retrieve the API key from the header, and perform validation.

```python ! api_key_usage.py
!from ./assets/fastapi/api_key_usage.py.txt
```

Now when generating the OpenAPI document, the API key authentication scheme will be included and only required for the listing on the `/burger/` endpoint.

</Spotlight>

## Summary

In this post, we've explored how you can set up a FastAPI-based SDK generation pipeline without hand-editing or updating OpenAPI documents. By using existing FastAPI methods for extending and customizing OpenAPI documents, you can improve the usability of your generated client SDKs.
