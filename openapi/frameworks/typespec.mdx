---
title: How To Generate an OpenAPI Spec With TypeSpec
description: "How to create OpenAPI schemas and SDKs from TypeSpec"
---

# How to Create OpenAPI Schemas and SDKs With TypeSpec

[TypeSpec](https://typespec.io/) is a brand-new domain-specific language (DSL) used to design APIs and generate API artifacts such as documentation, client SDKs, and server stubs.

Some consider TypeSpec to be a replacement for OpenAPI, but the goal of TypeSpec is to be used earlier in the planning process. OpenAPI can be used to design an API that does not yet exist (the API design-first workflow), or describe an API that already exists (API code-first workflow). TypeSpec focuses on the design-first workflow, providing a lightweight language for rapidly designing APIs in a TypeScript-like way, which can then be used to generate OpenAPI documents and other handy artifacts from a single source of truth.

TypeSpec has high level language constructs such as `model` for the structure or schema of your API's data, or `op` for operations in your API. 

```typespec
import "@typespec/http";

using Http;

model Store {
  name: string;
  address: Address;
}

model Address {
  street: string;
  city: string;
}

@route("/stores")
interface Stores {
  list(@query filter: string): Store[];
  read(@path id: Store): Store;
}
```

If you've used [OpenAPI](/openapi), these concepts translate to `schema` and `operation`, respectively.

```yaml
openapi: 3.2.0
info:
  title: (title)
  version: 0.0.0
tags: []
paths:
  /stores:
    get:
      operationId: Stores_list
      parameters:
        - name: filter
          in: query
          required: true
          schema:
            type: string
      responses:
        '200':
          description: The request has succeeded.
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Store'
  /stores/{id}:
    get:
      operationId: Stores_read
      parameters:
        - name: id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/Store'
      responses:
        '200':
          description: The request has succeeded.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Store'
components:
  schemas:
    Address:
      type: object
      required:
        - street
        - city
      properties:
        street:
          type: string
        city:
          type: string
    Store:
      type: object
      required:
        - name
        - address
      properties:
        name:
          type: string
        address:
          $ref: '#/components/schemas/Address'
```

The end goal for this guide is to create a high-quality TypeScript SDK. However, before we create an SDK, we'll need to learn how to generate an OpenAPI document based on a TypeSpec document. For that, we need to learn TypeSpec, and there is no better way to get started learning a new language than by asking _why_ it exists in the first place.

## The Problem TypeSpec Solves

Code generation is a force multiplier in API design and development. When an executive unironically asks, "How do we 10x API creation?", the unironic answer is: "API design-first + Code generation."

API design-first means specifying exactly what your application's programming interface will look like before anything gets built, getting stakeholders to approve these designs and mock servers before getting stuck into coding. Code generation means using those approved designs to generate server (stubs) and client libraries (SDKs), rapidly reducing the amount of code that needs to be manually written and cutting down on human error in the process.

As mentioned previously, OpenAPI is widely used for exactly this reason - it provides a human-readable (as YAML) description format for APIs, and comes with a thriving ecosystem of tools and code generators. So if OpenAPI exists, what can TypeSpec add?

The fundamental problem TypeSpec aims to solve is that writing OpenAPI documents by hand is complex, tedious, and error-prone. The complexity often leads to teams to abandon an design-first approach and instead start by coding their APIs without any of the usual review and feedback processes early on that can advert disaster. 

OpenAPI documents can become large and unwieldy, making them difficult to read and maintain. The YAML syntax can be verbose and repetitive, leading to duplication and inconsistencies. This confusion is because OpenAPI _can_ be used to both **design** an API that does not yet exist, and **describe** an API that already exists, but TypeSpec focuses on the former: TypeSpec helps teams rapidly design APIs with a simple TypeScript language that's a lot more friendly on the fingertips, without relying on [GUI editors](https://openapi.tools/#gui-editors) to wrestle OpenAPI's YAML for you. 

The workflow is writing TypeSpec early on in the planning process, rapidly prototyping APIs, and evolving them over time. All the while, CI/CD can convert TypeSpec to OpenAPI documents, powering API documentation, SDK generation, mock servers, and other handy artifacts from a tidy single source of truth.

Perhaps TypeSpec continues to be the source of truth forever, or perhaps it's ditched after the initial design phase. However you use it, TypeSpec aims to make API design-first easier, faster, and more enjoyable for those used to TypeScript and similar languages.

## A Brief Introduction to TypeSpec Syntax

To get started with TypeSpec, let's cover some of the basic syntax and concepts you'll need to understand to read and write TypeSpec specifications.

### Modularity in TypeSpec

The main entry point in TypeSpec is the `main.tsp` file. This file has the same role as the `index.ts` file in a TypeScript project.

Just like in TypeScript, we can organize code into files, folders, and modules, then [import](https://typespec.io/docs/language-basics/imports) these using the `import` statement. This helps split large API designs into smaller, more manageable parts. The difference between TypeScript and TypeSpec in this regard is that TypeSpec imports files, not code.

Here's an example of how you can import files, folders, and modules in TypeSpec:

```typescript filename="main.tsp"
import "./books.tsp"; // Import a file
import "./books"; // Import main.tsp in a folder
import "/books"; // Import a TypeSpec module's main.tsp file
```

We can install modules using npm, and use the `import` statement to import them into our TypeSpec project.

[Namespaces](https://typespec.io/docs/language-basics/namespaces), another TypeScript feature that TypeSpec borrows, allow you to group types and avoid naming conflicts. This is especially useful when importing multiple files that define types with the same name. Just like with TypeScript, namespaces may be nested and span multiple files.

Namespaces are defined using the `namespace` keyword, followed by the namespace name and a block of type definitions. Here's an example:

```typescript
namespace MyNamespace {
  model User {
    id: string;
    name: string;
  }
}
```

They may also be defined at the file level, using the `namespace` keyword followed by the namespace name and a block of type definitions. Here's an example:

```typescript
namespace MyNamespace;

model User {
    id: string;
    name: string;
}

model Post {
    id: string;
    title: string;
    content: string;
}
```

### Models in TypeSpec

[Models](https://typespec.io/docs/language-basics/models) in TypeSpec are similar to OpenAPI's `schema` objects. They define the structure of the data that will be sent and received by your API. We define models using the `model` keyword, followed by the model name and a block of properties. Here's an example:

```typescript filename="main.tsp"
model User {
    id: string;
    name: string;
    email: string;
}
```

Models are composable and extensible. You can reference other models within a model definition, extend a model with additional properties, and compose multiple models into a single model. Here's an example of model composition:

```typescript filename="main.tsp"
namespace WithComposition {
    model User {
        id: string;
        name: string;
        email: string;
    }

    model HasRole {
        role: string;
    }

    model Admin is User { // Copies the properties and decorators from User
        ...HasRole; // Extends the User model with the properties from the HasRole model
        level: number; // Adds a new property to the Admin model
    }
}

// The Admin model above will have the following properties:
namespace WithoutComposition {
    model Admin {
        id: string;
        name: string;
        email: string;
        role: string;
        level: number;
    }
}
```

The equivalent OpenAPI document for the `User` model above would look like this:

```yaml filename="openapi.yaml"
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        email:
          type: string
    HasRole:
      type: object
      properties:
        role:
          type: string
    Admin:
      allOf:
        - $ref: "#/components/schemas/User"
        - $ref: "#/components/schemas/HasRole"
        - type: object
          properties:
            level:
              type: integer
```

### Operations in TypeSpec

[Operations](https://typespec.io/docs/language-basics/operations) in TypeSpec are similar to OpenAPI operations. They describe the methods that users can call in your API. We define operations using the `op` keyword, followed by the operation name. Here's an example:

```typescript filename="main.tsp"
op listUsers(): User[]; // Defaults to GET
op getUser(id: string): User; // Defaults to GET
op createUser(@body user: User): User; // Defaults to POST with a body parameter
```

### Interfaces in TypeSpec

[Interfaces](https://typespec.io/docs/language-basics/interfaces) in TypeSpec group related operations together, similar to OpenAPI's `paths` object. We define interfaces using the `interface` keyword, followed by the interface name and a block of operations. Here's an example:

```typescript filename="main.tsp"
@route("/users")
interface Users {
    op listUsers(): User[]; // Defaults to GET /users
    op getUser(id: string): User; // Defaults to GET /users/{id}
    op createUser(@body user: User): User; // Defaults to POST /users
}
```

The equivalent OpenAPI for the `Users` interface above would look like this:

```yaml filename="openapi.yaml"
paths:
  /users:
    get:
      operationId: listUsers
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/User"
    post:
      operationId: createUser
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/User"
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
  /users/{id}:
    get:
      operationId: getUser
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
```

### Decorators in TypeSpec

[Decorators](https://typespec.io/docs/language-basics/decorators) in TypeSpec add metadata to models, operations, and interfaces. They start with the `@` symbol followed by the decorator name. Here's an example of the `@doc` decorator:

```typescript filename="main.tsp" mark=1,3,6,9
@doc("A user in the system")
model User {
    @doc("The unique identifier of the user")
    id: string;

    @doc("The name of the user")
    name: string;

    @doc("The email address of the user")
    email: string;
}
```

Decorators allow you to add custom behavior to TypeSpec definitions using JavaScript functions. You can [define your own decorators](https://typespec.io/docs/extending-typespec/create-decorators) or use built-in decorators provided by TypeSpec or third-party libraries.

### Learn More About TypeSpec

The language features above should be enough to help you find your way around a TypeSpec specification.

If you're interested in learning more about the TypeSpec language, see the [official documentation](https://typespec.io/docs/language-basics/overview).

We'll cover more detailed examples of TypeSpec syntax in our full example below.

## Generating an OpenAPI Document from TypeSpec

Now that we have a basic understanding of TypeSpec syntax, let's generate an OpenAPI document from a TypeSpec document.

### Step 1: Install the TypeSpec Compiler CLI

Install `tsp` globally using npm:

```bash filename="Terminal"
npm install -g @typespec/compiler
```

### Step 2: Create a TypeSpec Project

Create a new directory for your TypeSpec project and navigate into it:

```bash filename="Terminal"
mkdir typespec-example
cd typespec-example
```

Run the following command to initialize a new TypeSpec project:

```bash filename="Terminal"
tsp init
```

This will prompt you to select a template for your project. Choose the `Generic REST API` template and press enter. 

```
✔ Select a project template: Generic REST API
✔ Enter a project name: typespec-example-speakeasy
? What emitters do you want to use?:
❯ ◉ OpenAPI 3.1 document       [@typespec/openapi3]
  ◯ C# client                  [@typespec/http-client-csharp]
  ◯ Java client                [@typespec/http-client-java]
  ◯ JavaScript client          [@typespec/http-client-js]
  ◯ Python client              [@typespec/http-client-python]
  ◯ C# server stubs            [@typespec/http-server-csharp]
  ◯ JavaScript server stubs    [@typespec/http-server-js]
```

Depending on which emitters you select, the `tsp init` will install the necessary dependencies and create a `main.tsp` file in your project directory.

### Step 3: Write Your TypeSpec Specification

Open the `main.tsp` file in your text editor and write your TypeSpec specification. Here's an example of a simple TypeSpec document:

### Example TypeSpec File

Here's an example of a complete TypeSpec file for a Train Travel API:

```typescript
import "@typespec/http";
import "@typespec/openapi";
import "@typespec/openapi3";

using Http;
using OpenAPI;

/**
 * API for finding and booking train trips across Europe.
 *
 */
@service(#{ title: "Train Travel API" })
@info(#{
  version: "1.2.1",
  contact: #{
    name: "Train Support",
    url: "https://example.com/support",
    email: "support@example.com",
  },
  license: #{
    name: "Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International",
  },
})
@server("https://api.example.com", "Production")
@tagMetadata(
  "Stations",
  #{
    description: "Find and filter train stations across Europe, including their location and local timezone.",
  }
)
@tagMetadata(
  "Trips",
  #{
    description: "Timetables and routes for train trips between stations, including pricing and availability.",
  }
)
@tagMetadata(
  "Bookings",
  #{
    description: "Create and manage bookings for train trips, including passenger details and optional extras.",
  }
)
@tagMetadata(
  "Payments",
  #{
    description: "Pay for bookings using a card or bank account, and view payment status and history. **Warning:** Bookings usually expire within 1 hour so you'll need to make your payment before the expiry date.",
  }
)

namespace TrainTravelAPI;

/** A train station. */
model Station {
  /** Unique identifier for the station. */
  @format("uuid") id: string;

  /** The name of the station */
  name: string;

  /** The address of the station. */
  address: string;

  /** The country code of the station. */
  @format("iso-country-code") country_code: string;

  /** The timezone of the station in the [IANA Time Zone Database format](https://www.iana.org/time-zones). */
  timezone?: string;
}

/** A train trip. */
model Trip {
  /** Unique identifier for the trip */
  @format("uuid") id?: string;

  /** The starting station of the trip */
  origin?: string;

  /** The destination station of the trip */
  destination?: string;

  /** The date and time when the trip departs */
  departure_time?: utcDateTime;

  /** The date and time when the trip arrives */
  arrival_time?: utcDateTime;

  /** The name of the operator of the trip */
  operator?: string;

  /** The cost of the trip */
  price?: numeric;

  /** Indicates whether bicycles are allowed on the trip */
  bicycles_allowed?: boolean;

  /** Indicates whether dogs are allowed on the trip */
  dogs_allowed?: boolean;
}

/** A booking for a train trip. */
model Booking {
  /** Unique identifier for the booking */
  @format("uuid") id?: string;

  /** Identifier of the booked trip */
  @format("uuid") trip_id?: string;

  /** Name of the passenger */
  passenger_name?: string;

  /** Indicates whether the passenger has a bicycle. */
  has_bicycle?: boolean;

  /** Indicates whether the passenger has a dog. */
  has_dog?: boolean;
}

/** A problem detail object as defined in RFC 7807. */
model Problem {
  /** A URI reference that identifies the problem type */
  type?: string;

  /** A short, human-readable summary of the problem type */
  title?: string;

  /** A human-readable explanation specific to this occurrence of the problem */
  detail?: string;

  /** A URI reference that identifies the specific occurrence of the problem */
  instance?: string;

  /** The HTTP status code */
  status?: integer;
}

/** Returns a paginated and searchable list of all train stations. */
@tag("Stations")
@route("/stations")
@get
@summary("Get a list of train stations")
op `get-stations`(
  ...Parameters.page,
  ...Parameters.limit,

  /**
   * The latitude and longitude of the user's location, to narrow down the search results to sites within a proximity of this location.
   *
   */
  @query(#{ explode: true }) coordinates?: string,

  /**
   * A search term to filter the list of stations by name or address.
   *
   */
  @query(#{ explode: true }) search?: string,

  /** Filter stations by country code */
  @format("iso-country-code") @query(#{ explode: true }) country?: string,
):
  | {
      @header("Cache-Control") CacheControl?: string;
      @header RateLimit?: string;

      @body body: {
        data?: Station[];
        links?: {
          self?: url;
          next?: url;
          prev?: url;
        };
      };
    }
  | {
      @statusCode statusCode: 400;
      @header RateLimit?: string;
      @header contentType: "application/problem+json";
      @body body: Problem;
    };

/**
 * Returns a list of available train trips between the specified origin and destination stations on the given date.
 *
 */
@tag("Trips")
@route("/trips")
@get
@summary("Get available train trips")
op `get-trips`(
  ...Parameters.page,
  ...Parameters.limit,

  /** The ID of the origin station */
  @format("uuid") @query(#{ explode: true }) origin: string,

  /** The ID of the destination station */
  @format("uuid") @query(#{ explode: true }) destination: string,

  /** The date and time of the trip in ISO 8601 format in origin station's timezone. */
  @query(#{ explode: true }) date: utcDateTime,

  /** Only return trips where bicycles are known to be allowed */
  @query(#{ explode: true }) bicycles?: boolean,

  /** Only return trips where dogs are known to be allowed */
  @query(#{ explode: true }) dogs?: boolean,
):
  | {
      @header("Cache-Control") CacheControl?: string;
      @header RateLimit?: string;

      @body body: {
        data?: Trip[];
        links?: {
          self?: url;
          next?: url;
          prev?: url;
        };
      };
    }
  | {
      @statusCode statusCode: 400;
      @header RateLimit?: string;
      @header contentType: "application/problem+json";
      @body body: Problem;
    };

/** A booking is a temporary hold on a trip. It is not confirmed until the payment is processed. */
@tag("Bookings")
@route("/bookings")
@post
@summary("Create a booking")
op `create-booking`(
  /** Booking details */
  @body body: Booking,
):
  | {
      @statusCode statusCode: 201;
      @body body: Booking & {
        links?: { self?: url };
      };
    }
  | {
      @statusCode statusCode: 400;
      @header RateLimit?: string;
      @header contentType: "application/problem+json";
      @body body: Problem;
    };

namespace Parameters {
  model page {
    /** The page number to return */
    @minValue(1) @query(#{ explode: true }) page?: integer = 1;
  }
  model limit {
    /** The number of items to return per page */
    @minValue(1)
    @maxValue(100)
    @query(#{ explode: true })
    limit?: integer = 10;
  }
}
```

Let's break down some of the key features of this TypeSpec file:

#### Importing and Using Modules

The file starts by importing necessary TypeSpec modules:

```typescript
import "@typespec/http";
import "@typespec/openapi";
import "@typespec/openapi3";

using Http;
using OpenAPI;
```

These modules extend TypeSpec's capabilities for HTTP APIs and OpenAPI generation.

#### Namespace and Service Definition

The `TrainTravelAPI` namespace is decorated with several metadata decorators:

```typescript
@service(#{ title: "Train Travel API" })
@info(#{
  version: "1.2.1",
  contact: #{
    name: "Train Support",
    url: "https://example.com/support",
    email: "support@example.com",
  },
  license: #{
    name: "Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International",
  },
})
@server("https://api.example.com", "Production")
namespace TrainTravelAPI;
```

- `@service` marks this namespace as a service and provides its title
- `@info` provides additional information for the OpenAPI document
- `@server` defines the base URL for the API
- `@tagMetadata` provides descriptions for operation tags

#### Models with Validation

TypeSpec supports various validation decorators for model properties:

```typescript
/** A train station. */
model Station {
  /** Unique identifier for the station. */
  @format("uuid") id: string;

  /** The name of the station */
  name: string;

  /** The address of the station. */
  address: string;

  /** The country code of the station. */
  @format("iso-country-code") country_code: string;

  /** The timezone of the station */
  timezone?: string;
}
```

The `@format` decorator adds format annotations (which some OpenAPI tools may choose to validate), while the `?` makes properties optional.

#### Operations with Multiple Response Types

Operations can return different response types using union types:

```typescript
op `get-stations`(...params):
  | {
      @body body: {
        data?: Station[];
        links?: { /* ... */ };
      };
    }
  | {
      @statusCode statusCode: 400;
      @body body: Problem;
    };
```

This creates both successful (200) and error (400) responses in the generated OpenAPI.

#### Reusable Parameters

The `Parameters` namespace defines reusable parameter models:

```typescript
namespace Parameters {
  model page {
    /** The page number to return */
    @minValue(1) @query(#{ explode: true }) page?: integer = 1;
  }
  model limit {
    /** The number of items to return per page */
    @minValue(1)
    @maxValue(100)
    @query(#{ explode: true })
    limit?: integer = 10;
  }
}
```

These can be spread into operations using `...Parameters.page` and `...Parameters.limit`.

### Step 4: Generate the OpenAPI Document

You can generate an OpenAPI 3.1 document using the TypeSpec compiler:

```bash
tsp compile . --emit @typespec/openapi3
```

This will generate an OpenAPI JSON file in the `tsp-output/@typespec/openapi3` directory.

### Step 5: (Optional) Output as YAML

By default, the TypeSpec compiler outputs JSON. However, you can specify YAML output by updating your `tspconfig.yaml`:

```yaml
emit:
  - "@typespec/openapi3"
options:
  "@typespec/openapi3":
    output-file: "{output-dir}/openapi.yaml"
```

Running `tsp compile .` again will now generate a YAML file instead.

### Step 6: View the Generated OpenAPI Document

Open the generated OpenAPI document in your text editor or a YAML viewer to see the API specification.

### Generated OpenAPI Document Structure

When the TypeSpec compiler processes our specification, it generates an OpenAPI document. Here's what the structure of the generated OpenAPI document looks like:

#### OpenAPI Version

The document starts with the OpenAPI version:

```yaml
openapi: 3.1.0
```

This is determined by the `@typespec/openapi3` emitter we used, which generates OpenAPI 3.1 documents.

#### API Information

The `info` section contains metadata from our `@service` and `@info` decorators:

```yaml
info:
  title: Train Travel API
  version: 1.2.1
  contact:
    name: Train Support
    url: https://example.com/support
    email: support@example.com
  license:
    name: Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
  description: API for finding and booking train trips across Europe.
```

#### Tags

The `tags` section contains descriptions from our `@tagMetadata` decorators:

```yaml
tags:
  - name: Stations
    description: Find and filter train stations across Europe, including their location and local timezone.
  - name: Trips
    description: Timetables and routes for train trips between stations, including pricing and availability.
  - name: Bookings
    description: Create and manage bookings for train trips, including passenger details and optional extras.
```

#### Server Information

The server URL from our `@server` decorator:

```yaml
servers:
  - url: https://api.example.com
    description: Production
```

#### Paths and Operations

The operations from our TypeSpec file become paths in the OpenAPI document:

```yaml
paths:
  /stations:
    get:
      operationId: get-stations
      summary: Get a list of train stations
      description: Returns a paginated and searchable list of all train stations.
      tags:
        - Stations
      parameters:
        - $ref: '#/components/parameters/Parameters.page'
        - $ref: '#/components/parameters/Parameters.limit'
        - name: coordinates
          in: query
          required: false
          description: The latitude and longitude of the user's location
          style: form
          explode: true
          schema:
            type: string
      responses:
        '200':
          description: The request has succeeded.
          headers:
            Cache-Control:
              required: false
              schema:
                type: string
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Station'
                  links:
                    type: object
                    properties:
                      self:
                        type: string
                        format: uri
                      next:
                        type: string
                        format: uri
```

#### Components and Schemas

Our models become schemas in the `components` section:

```yaml
components:
  schemas:
    Station:
      type: object
      required:
        - id
        - name
        - address
        - country_code
      properties:
        id:
          type: string
          format: uuid
          description: Unique identifier for the station.
        name:
          type: string
          description: The name of the station
        address:
          type: string
          description: The address of the station.
        country_code:
          type: string
          format: iso-country-code
          description: The country code of the station.
        timezone:
          type: string
          description: The timezone of the station
      description: A train station.
```

#### Reusable Parameters

Our spread parameter models become reusable parameter components:

```yaml
components:
  parameters:
    Parameters.page:
      name: page
      in: query
      required: false
      description: The page number to return
      style: form
      explode: true
      schema:
        type: integer
        minimum: 1
        default: 1
    Parameters.limit:
      name: limit
      in: query
      required: false
      description: The number of items to return per page
      style: form
      explode: true
      schema:
        type: integer
        minimum: 1
        maximum: 100
        default: 10
```

### Step 7: Use the OpenAPI Document With Speakeasy

Now that you have a valid OpenAPI document, you can use it with Speakeasy to generate SDKs, documentation, and more. Refer to the [Speakeasy documentation](/docs) for more information on how to use the generated OpenAPI document.

## Adding OpenAPI Extensions for SDK Generation

TypeSpec allows you to add OpenAPI extensions using the `@extension` decorator. This is particularly useful for adding Speakeasy-specific extensions to customize SDK generation behavior.

### Adding Retries with OpenAPI Extensions

To add retry logic to operations, you can add the Speakeasy `x-speakeasy-retries` extension to your TypeSpec specification:

```typescript
@tag("Stations")
@route("/stations")
@get
@summary("Get a list of train stations")
@extension("x-speakeasy-retries", #{
  strategy: "backoff",
  backoff: #{
    initialInterval: 500,
    maxInterval: 60000,
    maxElapsedTime: 3600000,
    exponent: 1.5,
  },
  statusCodes: ["5XX"],
  retryConnectionErrors: true
})
op `get-stations`(
  ...Parameters.page,
  ...Parameters.limit,
  @query(#{ explode: true }) coordinates?: string,
  @query(#{ explode: true }) search?: string,
): /* ... responses ... */;
```

This generates the following extension in the OpenAPI document:

```yaml
paths:
  /stations:
    get:
      operationId: get-stations
      summary: Get a list of train stations
      x-speakeasy-retries:
        strategy: backoff
        backoff:
          initialInterval: 500
          maxInterval: 60000
          maxElapsedTime: 3600000
          exponent: 1.5
        statusCodes:
          - 5XX
        retryConnectionErrors: true
```

You can add similar extensions for other Speakeasy features like [pagination](/docs/customize-sdks/pagination), [error handling](/docs/customize-sdks/error-handling), and more.

### Step 8: Generate an SDK from the OpenAPI Document

Now that we have an OpenAPI document for our API, we can generate an SDK using Speakeasy.

Make sure you have [Speakeasy installed](/docs/speakeasy-cli/getting-started):

```bash filename="Terminal"
speakeasy --version
```

Then, generate a TypeScript SDK using the following command:

```bash filename="Terminal"
speakeasy quickstart
```

This command will:
1. Detect your OpenAPI document
2. Generate a TypeScript SDK in the `sdks/train-travel-ts` directory (or your chosen directory)
3. Set up proper retry logic, pagination, and other SDK features based on your OpenAPI extensions

After making changes to your TypeSpec file, you can regenerate both the OpenAPI document and SDK:

```bash
# Regenerate OpenAPI document
tsp compile . --emit @typespec/openapi3

# Regenerate SDK
speakeasy run
```

The `speakeasy run` command uses your existing Speakeasy configuration to regenerate the SDK with your latest changes.

## Common TypeSpec Pitfalls and Possible Solutions

While working with TypeSpec version 0.58.1, we encountered a few limitations and pitfalls that you should be aware of.

### 1. Limited Support for Model and Operation Examples

Examples only shipped as part of TypeSpec version 0.58.0, and the OpenAPI emitter is still in development. This means that the examples provided in the TypeSpec specification may not be included in the generated OpenAPI document.

To work around this limitation, you can provide examples directly in the OpenAPI document, preferably by using an [OpenAPI Overlay](/docs/prep-openapi/overlays/create-overlays).

Here's an overlay, saved as `train-travel-overlay.yaml`, that adds examples to the `Station` and `Trip` models in the OpenAPI document:

```yaml filename="train-travel-overlay.yaml"
overlay: 1.0.0
info:
  title: Add Examples to Station and Trip Models
  version: 1.0.0
actions:
  - target: $.components.schemas.Station
    update:
      example:
        id: "efdbb9d1-02c2-4bc3-afb7-6788d8782b1e"
        name: "Berlin Hauptbahnhof"
        address: "Europaplatz 1, 10557 Berlin, Germany"
        country_code: "DE"
        timezone: "Europe/Berlin"
  - target: $.components.schemas.Trip
    update:
      example:
        id: "4f4e4e1-c824-4d63-b37a-d8d698862f1d"
        origin: "Berlin Hauptbahnhof"
        destination: "Paris Gare du Nord"
        departure_time: "2024-02-01T10:00:00Z"
        arrival_time: "2024-02-01T16:30:00Z"
        operator: "Deutsche Bahn"
        price: 200
        bicycles_allowed: true
        dogs_allowed: true
```

Validate the overlay using Speakeasy:

```bash filename="Terminal"
speakeasy overlay validate -o train-travel-overlay.yaml
```

Then apply the overlay to the OpenAPI document:

```bash filename="Terminal"
speakeasy overlay apply -s tsp-output/schema/openapi.yaml -o train-travel-overlay.yaml > combined-openapi.yaml
```

If we look at the `combined-openapi.yaml` file, we should see the examples added to the `Station` and `Trip` models, for example:

```yaml filename="combined-openapi.yaml"
example:
  id: "4f4e4e1-c824-4d63-b37a-d8d698862f1d"
  origin: "Berlin Hauptbahnhof"
  destination: "Paris Gare du Nord"
  departure_time: "2024-02-01T10:00:00Z"
  arrival_time: "2024-02-01T16:30:00Z"
  operator: "Deutsche Bahn"
  price: 200
  bicycles_allowed: true
  dogs_allowed: true
```

### 2. Only Single Examples Supported

At the time of writing, the OpenAPI emitter only supports a single example for each operation or model. If you provide multiple examples using the `@opExample` decorator in the TypeSpec specification, only the last example will be included in the OpenAPI document.

OpenAPI version 3.0.0 introduced support for multiple examples using the `examples` field, and since OpenAPI 3.1.0, the singular `example` field is marked as deprecated in favor of multiple `examples`.

### 3. No Extensions at the Namespace Level

We found that the `x-speakeasy-retries` extension could not be added at the namespace level in the TypeSpec specification, even though Speakeasy supports this extension at the operation level.

The TypeSpec documentation on the [@extension](https://typespec.io/docs/libraries/openapi/reference/decorators#@TypeSpec.OpenAPI.extension) decorator does not mention any restrictions on where extensions can be applied, so this may be a bug or an undocumented limitation.

To work around this limitation, you can add the `x-speakeasy-retries` extension directly to the OpenAPI document using an overlay, as shown in the previous example, or by adding it to each operation individually in the TypeSpec specification.

### 4. No Support for Webhooks or Callbacks

TypeSpec does not yet support webhooks or callbacks, which are common in modern APIs. This means you cannot define webhook operations or callback URLs in your TypeSpec specification and generate OpenAPI documents for them.

To work around this limitation, you can define webhooks and callbacks directly in the OpenAPI document using an overlay, or by adding them to the OpenAPI document manually.

## The TypeSpec Playground

To help you experiment with TypeSpec and see how it translates to OpenAPI, the Microsoft team created a [TypeSpec Playground](https://typespec.io/playground).

We added our [TypeSpec specification](https://typespec.io/playground?e=%40typespec%2Fopenapi3&options=%7B%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZb3BlbmFwadwcM9UddmVyc2lvbmluZyI7Cgp1c2luZyBUeXBlU3BlYy5IdHRwO9AVT3BlbkFQSdEYVslKOwoKQHNlcnZpY2UoewogIHRpdGxlOiAiQm9vayBTdG9yZSBBUEkiLAp9KQpAaW5mb8YmZXJtc09mU8Y5OiAi5ADtczovL2Jvb2tzxDYuZXhhbXBsZS5jb20vxS8iLAogIGNvbnRhY3Q6IMRGICBuYW3EPkFQSSBTdXDkAPDFJiAgdXJs31ZtL3PNMmVtYWnENMcWQNU0xSx9xAVsaWNlbnNl8ACJcGFjaGUgMi4w9QCId3d3LmHFIy5vcmcvx0RzL0xJQ0VOU0UtMi4wLmh0bWzIZ%2BQBNOcBtWVkKOcBdXMp5gFyZXIoxVk6Ly8xMjcuMC4wLjE6NDAxMCIs8AF%2FIHYxIikKQGRvYyjlASxmb3IgbWFuYWfkAdVhIOQA6yDlAOwgaW52ZW50b3J5IGFuZCBvcmRlcnMiKQrkAN9zcGFjZSDEWcVYOwoKZW51bSDoAJblAQlgMeQAiGAsCn3HHlB1YmxpY2F0aW9u5AI9xSXEQ%2BQA4U1hZ2F6aW5lxS7mAJ1CYXNlIG1vZGVs5QCk5QGE5QCKbccs5ACNxiDLWsU2xFrGRVVuaXF1ZSBpZGVudGlmaWVyIinEHGtleQogIGlkOiBzdHLmArrIMlTkArUgb2YgdGhlIHDKWcU55wLS0TXrAIEgZGF0ZcUtxT1zaERhdGU6IHV0Y8QJVGlt5AEuyThyaWPkAWkgVVNExjTEETogZmxvYXQzMssq5QEyb2byAJJ5cGU68AFbO%2BQBRmNvbnN05QFhReYCtTEgPSAj5AEb5AD4IjEyM%2BUCW%2B0DpeUA%2FcUX%2BAC9LmZyb21JU08oIjIwMjAtMDEtMDFUMDA6xQNaIinFPOYAxTE5Ljk5xWP0AKQu6AH7YXV0aG9y5AMxxQkgTmFt5gCDaXNibuYAqTQ1Njc4OeQDSH078wDZMu0A2TQ1Nu0A2UFub3RoZXLFMf8A4fQA4TL6AOEyNP8A4fAA4ecAiuYA6ewA5DA5ODc2NTQzMjHnAORA5wRpKOwBwOgDt1JlcHJlc2VudHPoA7FpbuUCr%2BUDuOkDFsQ7IGV4dGVuZHP1AyP6ALfrAnnnAZbnAxHEbuUCeOgA1fEDC0lTQk7RLuYA58gs6QKd6AP29QKhNzg57QHIyC3%2FAcT0AcQz%2BgHE%2FgKkyHTEImlzc3VlTnVtYmVyOiAxy3%2FEEOYEAsQM6ALA6gKq7wDm7gKuMDEy9QKu%2FwDu%2FADuNPoA7jf%2FAO73AO4yy3%2FEEOkApukA9vACt%2FAB2vUCu%2BgFyfYCv8hD%2FwLD%2FADJ7AKX5ADQIG7lANHoAp%2FoAIDnAqPrAPFpbu4FfuoB3tQ76wEa8QLj6wCb6wLm7APW6QIo0ivkAivwAUrsAWbTXeQBaWlzY3JpbWluYXRvcigi5AEj5Afyb25lT2YKdW7kBqTLOeUBR%2BQDqTrpB43oAN069AeXUG9zc2libOQBrmF0dXNlc%2BUHnmFu5gghIinmB%2BxPxA1TxSLFYVBlbmRpbmfEXlNoaXBwZWTEC0RlbGl2ZXLGDUNhbmNlbGzEDeoDPMVI9QQfYWJj5goGdXN0b21lcknsBtVpdGVtczogI1vsAWks8QFMXcQsdG90YWzlB4k6IDI5Ljk4xBXmAN067ADILukAxO0C6u0AovQC5%2BcBGuUBJ%2BsHvuoIvsVC%2FAi0xTvkAnboAWP3CLtD5wELIHdobyBwbGFjZWTPN%2BwBLdE%2FTGlzdO8IY3PoA5vLeuYBW%2BsCQltdy0VU5AFO5gRv6AMsyjzsAWvyCOPnAi%2FRNvMBjOUDYcY2T3BlcucArO0Ky%2B8Ba0B0YWcoItAVcm91dGUoIi%2FPGGludGVyZuQK4%2BsA5%2BYCyUDlBI7kCuYoIngtc3BlYWtlYXN5LXJldHJpZXMiLMUm5AC1cmF0ZWd5OiAiYmFja29mZucMBscO6AwtICBpbml0aWFsScR0dmFsOiA1MDDGK%2BQDinjKGDYwMM0aRWxhcHNlZOQGAzogM8UeyR9leHBvbmVudDogMS41xhXlDKvoAU5Db2RlczogWyI1WFgi5QMHICDkAMN5Q29ubmVj5QRScnJvcnM6IHRydWXkDIPlCzlvcOcC6ygje8QxdXLlBXL%2FA2vkA2vHQeoCamFsbPABpcVh5wHPSWQoImxpc3TsAYLFI8QVKCn1AoLtAJ5wYXJhbWV0ZeQAxCN76gr1IH0s7QC67Qsi6wClR2V0IGEg5A8taWZpY%2BwAqyBieSBJ5guw7gCwZ2XsAK%2FFIWdldChAcGF0aOsDs%2B4AvSB8IOUBa%2FIAw%2BUBlu8Ax%2BsAh%2FAAu%2BkBxvUA28Qe6wDeQ3JlYXRlIGEgbmV3zFXzANZjxSvwANnGFihAYm9kecxB7QDc%2BADq%2FwO%2BZ%2BoObuYDuMoP6AOyyRLqA6zlBCDnA6b%2FAUfGYOcEU%2FwBQs0h7wFDUOQFYucBQuoEru4BPOUFhsVFxR3KD%2BcBOewAiCnHCPoCEf8C1PcAt%2FEC1egGkvsCx%2BoAs8gN9ALG%2FwCv9AF56g589Qdk5wgd%2FwGL8QGLVXDkD3bnCkXoBkbrCJTwAOJ1xTDLecUkxhbGEfEA7ywg5gGy8wC28gEK5ALg6AghI3sgY29kZTogNDA0LCBtZXNzYWfkC%2BrsAxlub3QgZm91bmQi5ADWQGXERucDIsVSIHJlc3BvbnPqCx7GF%2BoINcYQxGnmA57FcvAKx8Yl5wCDxSjHDOwKuQ%3D%3D) to the playground. You can view the generated OpenAPI document and SDK, or browse a generated Swagger UI for the API.

## Further Reading

This guide barely scratches the surface of what you can do with TypeSpec. This small language is evolving rapidly, and new features are being added all the time.

Here are some resources to help you learn more about TypeSpec and how to use it effectively:

- [TypeSpec Documentation](https://typespec.io/docs): The official TypeSpec documentation provides detailed information on the TypeSpec language, standard library, and emitters.
- [TypeSpec Releases](https://github.com/microsoft/typespec/releases): Keep up with the latest TypeSpec releases and updates on GitHub.
- [TypeSpec Playground](https://typespec.io/playground): Worth mentioning again: experiment with TypeSpec in the browser, generate OpenAPI documents, and view the resulting Swagger UI.
- [Speakeasy Documentation](/docs): Speakeasy has extensive documentation on how to generate SDKs from OpenAPI documents, customize SDKs, and more.
- [Speakeasy OpenAPI Reference](/openapi): For a detailed reference on the OpenAPI specification.
