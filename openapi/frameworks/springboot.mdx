---
title: How To Generate an OpenAPI Document With Spring Boot
description: "Generating an OpenAPI document with Spring Boot and using it to create SDKs with Speakeasy."
---

import { Callout } from "@/mdx/components";

# Generating an OpenAPI document and SDK from Spring Boot

This guide demonstrates how to generate OpenAPI documents directly from Spring Boot code and use them to create and customize SDKs. Rather than writing and maintaining separate OpenAPI documents, this approach extracts specifications from the application code itself.

The guide uses a simple bookstore API example to demonstrate how to properly document API structures, including inheritance between models, endpoint definitions, response types, and error handling. The examples illustrate how Spring Boot annotations map to OpenAPI concepts and how code translates into API specifications.

<Callout title="Example repository" type="info">
  This guide walks through creating a Spring Boot
  project, adding the necessary dependencies, writing Spring Boot controllers
  with OpenAPI annotations, and generating an OpenAPI document. To skip
  this setup, clone the [example
  application](https://github.com/speakeasy-api/examples/tree/main/framework-springboot).
  The example uses Java 25 and Spring Boot 4.0.3.
</Callout>

## Setting up a Spring Boot project

First, create a new Spring Boot project using [Spring Initializr](https://start.spring.io/). Select the following options:

- Project: Maven
- Spring Boot: 4.0.x (or the latest stable version)
- Java: 25 (or the latest LTS version)
- Project Metadata: Fill in as appropriate
- Dependencies: Spring Web

Download the project and extract it to your preferred directory.

## Adding OpenAPI dependencies

Open the `pom.xml` file and add the following dependency:

```xml filename="pom.xml"
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>3.0.1</version>
</dependency>
```

## Configuring application properties

Open the `src/main/resources/application.properties` file and add the following configuration:

```properties filename="application.properties"
spring.application.name=bookstore-api

# Specify the path of the OpenAPI documentation
springdoc.api-docs.path=/api-docs

# Specify the OpenAPI version to use (e.g., OPENAPI_3_0 or OPENAPI_3_1)
springdoc.api-docs.version=OPENAPI_3_1

# Disable the Swagger UI, we only want the OpenAPI
springdoc.swagger-ui.enabled=false
```

These properties configure the endpoint where the OpenAPI document will be available (`/api-docs`). Spring Boot 4.0 with springdoc-openapi 3.0.1 defaults to OpenAPI 3.1, so while there's no need to explicitly configure the version, it doesn't hurt to be specific.

After starting your application, you can view the OpenAPI document at `http://localhost:8080/api-docs` for JSON or `http://localhost:8080/api-docs.yaml` for YAML.

## Writing a Spring Boot application

All the code for this step is available in the example application.

The `src/main/java/com/bookstore/BookstoreApplication.java` file contains the starting point for adding OpenAPI annotations to the project.

### Defining the main application configuration with annotations

The `BookstoreApplication` class is the entry point for the API, and it's also where the main OpenAPI documentation properties are defined:

```java filename="BookstoreApplication.java"
package com.bookstore;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Contact;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.info.License;
import io.swagger.v3.oas.annotations.servers.Server;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@OpenAPIDefinition(
        info = @Info(
                title = "Bookstore API",
                version = "1.0.0",
                description = "This API provides endpoints to manage a bookstore's inventory of books and magazines, " +
                        "as well as customer orders. You can use it to browse publications, create orders, and track " +
                        "order status.",
                contact = @Contact(
                        name = "Bookstore API Support",
                        email = "api@bookstore.example.com",
                        url = "https://bookstore.example.com/support"
                ),
                license = @License(
                        name = "Apache 2.0",
                        url = "https://www.apache.org/licenses/LICENSE-2.0.html"
                )
        ),
        servers = {
                @Server(url = "https://api.bookstore.example.com", description = "Production server (uses live data)"),
                @Server(url = "http://localhost:8080", description = "Development server (uses test data)")
        }
)
public class BookstoreApplication {
    public static void main(String[] args) {
        SpringApplication.run(BookstoreApplication.class, args);
    }
}
```

The `@OpenAPIDefinition` annotation populates the OpenAPI document with essential context for anyone who wants to use the API. The `title`, `version`, and `description` fields describe what the API does, its current state, and how it can be used.

The `@Server` annotation defines available endpoints for the API. In the example, there are two options:

- A production server at `https://api.bookstore.example.com` that uses live data
- A localhost server at `http://localhost:8080` for testing with sample data

### Defining data models with annotations

OpenAPI annotations can be used to describe API data structures in the `Models.java` file:

```java filename="Models.java"
package com.bookstore;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Schema(description = "Base class for all publications")
@JsonTypeInfo(
        use = JsonTypeInfo.Id.NAME,
        property = "type",
        visible = true
)
@JsonSubTypes({
        @JsonSubTypes.Type(value = Book.class, name = "BOOK"),
        @JsonSubTypes.Type(value = Magazine.class, name = "MAGAZINE")
})
public abstract class Publication {
    @Schema(description = "Unique identifier of the publication", example = "123e4567-e89b-12d3-a456-426614174000")
    protected String id;

    @Schema(description = "Title of the publication", example = "Spring Boot in Action")
    protected String title;

    @Schema(description = "Publication date in ISO format", example = "2023-05-15")
    protected String publicationDate;

    @Schema(description = "Price in USD", example = "29.99")
    protected float price;

    @JsonProperty("type")
    @Schema(description = "Type of publication", example = "BOOK", allowableValues = {"BOOK", "MAGAZINE"})
    protected abstract String getType();

    // Getters and setters omitted for brevity
}

@Schema(description = "Book publication with author and ISBN")
class Book extends Publication {
    @Schema(description = "Author of the book", example = "Craig Walls")
    private String author;

    @Schema(description = "ISBN of the book", example = "978-1617292545")
    private String isbn;

    @Override
    @JsonIgnore
    protected String getType() {
        return "BOOK";
    }

    // Constructor, getters, and setters omitted for brevity
}

@Schema(description = "Magazine publication with issue number and publisher")
class Magazine extends Publication {
    @Schema(description = "Issue number of the magazine", example = "42")
    private int issueNumber;

    @Schema(description = "Publisher of the magazine", example = "O'Reilly Media")
    private String publisher;

    @Override
    @JsonIgnore
    protected String getType() {
        return "MAGAZINE";
    }

    // Constructor, getters, and setters omitted for brevity
}
```

The `@Schema` annotation can be used at both the class and field levels:

- At the class level, `@Schema` describes what a `Publication`, `Book`, or `Magazine` represents in the API.
- At the field level, fields like `id` and `author` are documented with a description and example values.

The `Publication` class acts as the base schema in the OpenAPI specification. By using `@JsonTypeInfo` and `@JsonSubTypes`, the annotations specify that a `Publication` can be either a `Book` or `Magazine`. This polymorphism is reflected in the OpenAPI document as a `oneOf` schema, allowing endpoints to accept or return either type. API clients will include a `type` field set to either `BOOK` or `MAGAZINE` to identify the publication type.

The `Order` class can be defined to reference the `Publication` schema:

```java filename="Models.java"
@Schema(description = "Customer order for publications")
class Order {
    @Schema(description = "Unique identifier of the order", example = "order-123456")
    private String id;

    @Schema(description = "Name of the customer who placed the order", example = "John Doe")
    private String customerName;

    @Schema(description = "Email of the customer", example = "john.doe@example.com")
    private String customerEmail;

    @Schema(description = "List of publications in the order")
    private List<Publication> items;

    @Schema(description = "Current status of the order", example = "PENDING")
    private OrderStatus status;

    // Constructor, getters, and setters omitted for brevity
}
```

The `Order` class uses the `@Schema` annotation to document the `items` field, which references the `Publication` schema. This indicates to OpenAPI that `Orders` can contain an array of either books or magazines, using the polymorphic structure defined earlier.

For the order status, an enumeration is used:

```java filename="Models.java"
@Schema(description = "Status of an order")
enum OrderStatus {
    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED
}
```

This appears in the OpenAPI document as a string field with a set of allowed values.

An error response can be defined using a Java record, which is a concise way to define immutable data carriers introduced in Java 14 and stable since Java 16. This error response follows the RFC 7807 Problem Details standard:

```java filename="Models.java"
@Schema(description = "Represents an RFC 7807 Problem Details error response")
public record ErrorResponse(
    @Schema(description = "A URI reference that identifies the problem type", 
            example = "https://api.bookstore.example.com/problems/resource-not-found")
    String type,
    @Schema(description = "A short, human-readable summary of the problem type", 
            example = "Resource Not Found")
    String title,
    @Schema(description = "The HTTP status code", example = "404")
    int status,
    @Schema(description = "A human-readable explanation specific to this occurrence", 
            example = "The publication with ID '123e4567-e89b-12d3-a456-426614174000' was not found")
    String detail,
    @Schema(description = "A URI reference that identifies the specific occurrence of the problem", 
            example = "/publications/123e4567-e89b-12d3-a456-426614174000", nullable = true)
    String instance
) {}
```

The ErrorResponse follows RFC 7807 Problem Details, which defines a standard format for HTTP API error responses. Key fields include:

- `type`: A URI that identifies the problem type (e.g., `https://api.bookstore.example.com/problems/out-of-stock`)
- `title`: A human-readable summary that remains consistent for this error type
- `status`: The HTTP status code for this occurrence
- `detail`: A specific explanation of what went wrong
- `instance`: A URI identifying where this specific error occurred

Each of these properties is described and has generic example values provided, which can be overridden at the controller level when returning specific errors.

### Defining API endpoints with annotations

The API endpoints are defined in the `PublicationsController.java` file:

```java filename="PublicationsController.java"
package com.bookstore;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/publications")
@Tag(name = "Publications", description = "Operations for managing publications (books and magazines)")
public class PublicationsController {
    // Controller methods follow
}
```

The `@Tag` annotation groups operations under "Publications" in the OpenAPI document. Combined with `@RequestMapping("/publications")`, it tells API consumers that these endpoints handle publication-related operations.

For each endpoint method, we use annotations to document their purpose and responses:

```java filename="PublicationsController.java"  
@Operation(summary = "Get a publication by ID", description = "Returns a single publication (book or magazine)")
@ApiResponses(value = {
    @ApiResponse(responseCode = "200", description = "Successful operation",
                 content = @Content(schema = @Schema(oneOf = {Book.class, Magazine.class}))),
    @ApiResponse(responseCode = "404", description = "Publication not found",
                 content = @Content(mediaType = "application/problem+json", 
                                    schema = @Schema(implementation = ProblemDetail.class)))
})
@GetMapping("/{id}")
public ResponseEntity<?> getPublication(
    @Parameter(description = "ID of the publication to return", required = true)
    @PathVariable String id) {
    if ("123".equals(id)) {
        return ResponseEntity.ok(new Book("123", "Spring Boot in Action", 
            "2015-10-01", 39.99f, "Craig Walls", "978-1617292545"));
    } else {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, "Publication not found");
        problem.setTitle("Publication Not Found");
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
}
```

The `@Operation` and `@ApiResponses` annotations document what the endpoint does and what responses to expect. For example, `getPublication` is annotated to show that it returns a publication successfully (`200` status) or returns an error (`404` status) when the publication isn't found.

Spring Boot 4.0 includes enhanced support for [RFC 7807 Problem Details](https://datatracker.ietf.org/doc/html/rfc7807), a [standardized format for HTTP API error responses](/api-design/errors#rfc-9457---problem-details-for-http-apis). The `ProblemDetail` class provides a consistent structure for error responses with fields like `type`, `title`, `status`, `detail`, and optional extension properties. The media type `application/problem+json` indicates this standardized format.

The `@Parameter` annotation describes the requirements for input parameters, such as the ID path parameter in this example.

## Examining the generated OpenAPI document

After building the Spring Boot application, the OpenAPI document can be generated and examined to understand how the Java code translates into API specifications.

First, install the necessary dependencies in the project and start the application with the following commands:

```bash filename="Terminal"
./mvnw clean install
./mvnw spring-boot:run
```

Download the OpenAPI document while running the application:

```bash filename="Terminal"
curl http://localhost:8080/api-docs.yaml -o openapi.yaml
```

This command saves the OpenAPI document as `openapi.yaml` in the current directory.

The generated OpenAPI document can be explored to see how the Spring Boot annotations translate into an OpenAPI specification.

### The OpenAPI Specification version information

The OpenAPI document begins with version information:

```yaml filename="openapi.yaml"
openapi: 3.1.0
```

This version is determined by the configuration in our `application.properties` file. It tells API consumers which version of the OpenAPI Specification to expect.

### API information

Next comes the `info` object, which is generated from the `@OpenAPIDefinition` annotation:

```yaml filename="openapi.yaml"
info:
  title: Bookstore API
  description: >-
    This API provides endpoints to manage a bookstore's inventory of books and
    magazines, as well as customer orders. You can use it to browse
    publications, create orders, and track order status.
  contact:
    name: Bookstore API Support
    url: https://bookstore.example.com/support
    email: api@bookstore.example.com
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.html
  version: 1.0.0
```

Notice how each field in the Java annotation maps directly to its counterpart in the OpenAPI document output. This one-to-one mapping makes it easy to understand how your code affects the final API documentation.

### Server information

Server configurations defined with `@Server` annotations appear in the servers array:

```yaml filename="openapi.yaml"
servers:
  - url: https://api.bookstore.example.com
    description: Production server (uses live data)
  - url: http://localhost:8080
    description: Development server (uses test data)
```

### Polymorphic models

One of the more complex aspects of the API is how polymorphic models are represented. The `Publication` class is translated into a schema that supports polymorphism through a discriminator:

```yaml filename="openapi.yaml"
Publication:
  type: object
  description: Base class for all publications
  properties:
    id:
      type: string
      description: Unique identifier of the publication
      example: 123e4567-e89b-12d3-a456-426614174000
    title:
      type: string
      description: Title of the publication
      example: Spring Boot in Action
    publicationDate:
      type: string
      description: Publication date in ISO format
      example: "2023-05-15"
    price:
      type: number
      format: float
      description: Price in USD
      example: 29.99
    type:
      type: string
      description: Type of publication
      example: BOOK
      enum:
        - BOOK
        - MAGAZINE
  required:
    - id
    - title
    - publicationDate
    - price
    - type
  discriminator:
    propertyName: type
    mapping:
      BOOK: "#/components/schemas/Book"
      MAGAZINE: "#/components/schemas/Magazine"
```

Key aspects to notice:

- The `@Schema` annotations provide descriptions and examples
- The `@JsonTypeInfo` annotation determines the discriminator property
- The `@JsonSubTypes` annotation defines the possible concrete implementations

### API endpoints

Controller methods translate into API endpoints. The `getPublication` endpoint appears in the OpenAPI document as follows:

```yaml filename="openapi.yaml"
/publications/{id}:
  get:
    tags:
      - Publications
    summary: Get a publication by ID
    description: Returns a single publication (book or magazine)
    operationId: getPublication
    parameters:
      - name: id
        in: path
        description: ID of the publication to return
        required: true
        schema:
          type: string
    responses:
      "200":
        description: Successful operation
        content:
          application/json:
            schema:
              type: object
              oneOf:
                - $ref: "#/components/schemas/Book"
                - $ref: "#/components/schemas/Magazine"
      "404":
        description: Publication not found
        content:
          application/problem+json:
            schema:
              $ref: "#/components/schemas/ProblemDetail"
```

The mapping is clear:

- The `@Operation` annotation provides the summary and description.
- Each `@ApiResponse` maps to an entry in the responses object.
- The `@Parameter` annotation documents the path parameter.

## Creating an SDK from the OpenAPI document

After generating an OpenAPI document for the Spring Boot API, an SDK can be created using Speakeasy.

First, ensure Speakeasy is installed:

```bash filename="Terminal"
speakeasy --version
```

Generate a TypeScript SDK using the following command:

```bash filename="Terminal"
speakeasy quickstart
```

Follow the onscreen prompts to provide the configuration details for the new SDK, such as the name, schema location, and output path. Enter `openapi.yaml` when prompted for the OpenAPI document location and select the preferred language (for example, TypeScript) when prompted.

The terminal will display the steps taken by Speakeasy to create the SDK:

```bash filename="Terminal"
│ Workflow - running
│ Workflow - success
│ └─Target: sdk - success
│   └─Source: Bookstore API - success
│     └─Validating Document - success
│     └─Diagnosing OpenAPI - success
│     └─Tracking OpenAPI Changes - success
│       └─Snapshotting OpenAPI Revision - success
│       └─Storing OpenAPI Revision - success
│   └─Validating gen.yaml - success
│   └─Generating Typescript SDK - success
│     └─Setup Environment - success
│     └─Load and Validate Document - success
│     └─Generate SDK - success
│     └─Compile SDK - success
│     └─Setup Environment - success
│     └─Load and Validate Document - success
│     └─Generate SDK - success
│   └─Generating Code Samples - success
│     └─Snapshotting Code Samples - success
│       └─Snapshotting Code Samples - success
│       └─Uploading Code Samples - success
```

Speakeasy [validates](/docs/sdks/core-concepts#validation) the OpenAPI document to check that it's ready for code generation. Validation issues will be printed in the terminal. The generated SDK will be saved as a folder in the project.

If ESLint styling errors occur, run the `speakeasy quickstart` command from outside the project.

Speakeasy also suggests improvements for the SDK using [Speakeasy Suggest](/docs/prep-openapi/maintenance), an AI-powered tool in Speakeasy Studio. Suggestions can be viewed by opening the link to the Speakeasy Studio workspace in the terminal:

![Speakeasy Suggestions in Speakeasy Studio](/assets/openapi/springboot/speakeasy-suggestions.png)

After running this command, the generated SDK code will be in the specified output directory. This SDK can be used by clients to interact with the Spring Boot API in a type-safe manner.

The SDK `README.md` file contains documentation about the Speakeasy SDK. TypeScript SDKs generated with Speakeasy include an installable [Model Context Protocol (MCP) server](/docs/standalone-mcp/build-server) where the various SDK methods are exposed as tools that AI applications can invoke.
The SDK documentation includes instructions for installing the MCP server.

Note that the SDK is not ready for production use. To get it production-ready, follow the steps outlined in your Speakeasy workspace.

## Customizing the SDK

The example app added retry logic to the SDK's `listPublications` operation to handle network errors gracefully. This was done using one of [Speakeasy's OpenAPI extensions](/docs/speakeasy-reference/extensions), `x-speakeasy-retries`.

Instead of modifying the OpenAPI document directly, this extension was added to the Spring Boot controller, and the OpenAPI document and SDK were regenerated.

These imports were added to `src/main/java/com/bookstore/PublicationsController.java`:

```java filename="PublicationsController.java"
import io.swagger.v3.oas.annotations.extensions.Extension;
import io.swagger.v3.oas.annotations.extensions.ExtensionProperty;
```

The `listPublications` operation was modified to include the retry configuration:

```java filename="PublicationsController.java" mark=2:7
    @Operation(summary = "List all publications", description = "Get a list of all publications in the store", extensions = {
        @Extension(name = "x-speakeasy-retries", properties = {
            @ExtensionProperty(name = "strategy", value = "backoff"),
            @ExtensionProperty(name = "backoff", parseValue = true, value = "{\"initialInterval\":500,\"maxInterval\":60000,\"maxElapsedTime\":3600000,\"exponent\":1.5}"),
            @ExtensionProperty(name = "statusCodes", parseValue = true, value = "[\"5XX\"]"),
            @ExtensionProperty(name = "retryConnectionErrors", parseValue = true, value = "true")
        })
    })
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Successful operation",
                     content = @Content(array = @ArraySchema(schema = @Schema(implementation = PublicationListItem.class)))),
    })
    @GetMapping
    public ResponseEntity<List<Publication>> listPublications() {
        // This is a mock implementation. In a real application, you would fetch this from a database.
        List<Publication> publications = new ArrayList<>();
        publications.add(new Book(UUID.randomUUID().toString(), "Spring Boot in Action", "2015-10-01", 39.99f, "Craig Walls", "978-1617292545"));
        publications.add(new Magazine(UUID.randomUUID().toString(), "National Geographic", "2023-06-01", 9.99f, 6, "National Geographic Society"));
        return ResponseEntity.ok(publications);
    }
```

The OpenAPI document was then regenerated:

```bash filename="Terminal"
curl http://localhost:8080/api-docs.yaml -o openapi.yaml
```

The OpenAPI document includes the retry configuration for the `listPublications` operation:

```yaml filename="openapi.yaml"
x-speakeasy-retries:
  statusCodes:
    - 5XX
  backoff:
    initialInterval: 500
    maxInterval: 60000
    maxElapsedTime: 3600000
    exponent: 1.5
  strategy: backoff
  retryConnectionErrors: true
```

After recreating the SDK using Speakeasy:

```bash
speakeasy quickstart
```

The generated SDK now includes retry logic for the `listPublications` operation, automatically handling network errors and `5XX` responses.

### Issues and feedback

Need some assistance or have a suggestion? Reach out to our team at [support@speakeasy.com](mailto:support@speakeasy.com).

If you haven't already, take a look at our [blog](/blog) to learn more about OpenAPI, SDK generation, and more, including:

- [Native JSONL support in your SDKs](/blog/release-jsonl-support)
- [Comprehensive SDK testing](/blog/release-sdk-testing)
- [Model Context Protocol: TypeScript SDKs for the agentic AI ecosystem](/blog/release-model-context-protocol)
