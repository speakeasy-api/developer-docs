---
title: "Gram Functions"
description: "Build custom tools with TypeScript functions for complete control over logic and dependencies."
asIndexPage: true
---

Gram Functions are compact code units that represent LLM tools. They allow you to create tools from TypeScript code, deploy them to Gram, and expose them to language models via MCP servers. Once deployed, Gram Functions can be used just like any other tool in the Gram platform, allowing you to create and host MCP servers, combine them with other tools into toolsets, build multi-tool workflows, and more.

```typescript filename="gram.ts"
import { Gram } from "@gram-ai/functions";
import * as z from "zod/mini";

const gram = new Gram().tool({
  name: "greet",
  description: "Greet someone special",
  inputSchema: { name: z.string() },
  async execute(ctx, input) {
    return ctx.text(`Hello, ${input.name}!`);
  },
});

export default gram;
```

## Getting started

To get started with Gram Functions, scaffold a new project using the Gram template:

```bash
pnpm create @gram-ai/function@latest --template gram
```

Install the required package:

```bash
pnpm add @gram-ai/functions
```

For a complete walkthrough, follow the [Getting Started](/docs/mcp/getting-started/typescript) guide.

## Writing tools

You can write Gram Functions using the [Gram Functions Framework](/docs/mcp/build/gram-functions/functions-framework) or the official [Gram MCP SDK](/docs/mcp/build/gram-functions/mcp-sdk).
The Functions Framework is a more lightweight way to write tools, while MCP SDK support is available if you prefer to use the official SDK.

```typescript filename="gram-framework.ts"
import { Gram } from "@gram-ai/functions";
import * as z from "zod/mini";

const gram = new Gram().tool({
  name: "greet",
  description: "Greet someone special",
  inputSchema: { name: z.string() },
  async execute(ctx, input) {
    return ctx.text(`Hello, ${input.name}!`);
  },
});

export default gram;
```

## Deploying to Gram

Gram allows you to easily deploy and host your tools. Beyond hosting and running code for you, 
Gram offers a comprehensive set of features to help you build on top of your tools and deliver a powerful AI-native experience to your users. 
Follow the [Build and deploy](/docs/mcp/build/gram-functions/build-deploy) guide to learn more.

```bash
npm run build
npm run push
```

## Functions vs MCP servers

Gram Functions provide a way to create individual tools for use in MCP servers. However, creating tools in Gram is not the same as creating MCP servers.

The key distinction:

- **Functions:** Individual tools that represent specific capabilities or operations
- **MCP Servers:** Collections of tools combined into a single server that can be accessed by LLM clients

Once you have created a tool (via Functions or OpenAPI), combine it with other tools into one or many MCP servers. This means you can:

- Split your Gram Functions into multiple projects for convenience
- Keep every tool in one file
- Organize tools however makes sense for your workflow

MCP servers are created from [toolsets](/docs/mcp/reference/concepts/toolsets) later in the Gram dashboard. Tools can also be created directly from OpenAPI documents.

### Local development

That said, you can run Gram Functions as a local MCP server with the [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector) for testing and development purposes. Use the following command:

```bash
pnpm run dev
```