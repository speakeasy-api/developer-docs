{/* TODO 
- OG does not handle any polymorphism whatsoever, no allof or anyOf 
*/}

import { Table } from "@/mdx/components";

# Comparing OpenAPI PHP SDK Generators

The biggest generator of SDKs (a.k.a API clients) in PHP is the multilingual open-source generator [OpenAPI Generator](https://openapi-generator.tech/), but so many of our users have switched to Speakeasy for their PHP SDKs it seemed helpful to compare the offerings and help others make an informed decision.

Open-source OpenAPI generators are great for experimentation but lack the reliability, performance, and intuitive developer experience required for critical applications. As an alternative, Speakeasy creates [idiomatic SDKs](/post/client-sdks-as-a-service) that meet the bar for enterprise use.

Here's the high-level summary of the differences between Speakeasy and OpenAPI Generator:

<Table
  columns={[
    { key: "feature", header: "Feature" },
    { key: "speakeasy", header: "Speakeasy" },
    { key: "openapi", header: "OpenAPI Generator" }
  ]}
  data={[
    { feature: "OpenAPI 3.2 support", speakeasy: "✅", openapi: "❌" },
    { feature: "OpenAPI 3.1 support", speakeasy: "✅", openapi: "⚠️ Beta" },
    { feature: "PHP version support", speakeasy: "PHP >=8.2", openapi: "PHP >=8.1" },
    { feature: "Laravel integration", speakeasy: "✅", openapi: "❌" },
    { feature: "Type safety", speakeasy: "✅", openapi: "❌" },
    { feature: "Runtime type checking", speakeasy: "✅ JMS Serializer", openapi: "❌" },
    { feature: "Async support", speakeasy: "✅", openapi: "✅" },
    { feature: "OAuth 2.0 support", speakeasy: "⚠️ Implict grant only", openapi: "⚠️ Implict grant only" },
    { feature: "Serialization", speakeasy: "✅ JMS Serializer", openapi: "✅ PHP extensions" },
    { feature: "Enum support", speakeasy: "✅", openapi: "⚠️ Uses getter/setter workarounds" },
    { feature: "Union type handling", speakeasy: "✅", openapi: "⚠️ Creates custom implementation" },
    { feature: "Content type support", speakeasy: "JSON and Form", openapi: "JSON, Form, and XML" },
    { feature: "Documentation", speakeasy: "✅", openapi: "⚠️ Examples may lack required fields" },
    { feature: "CI/CD integration", speakeasy: "✅", openapi: "❌" }
  ]}
/>

In this post, we'll do a technical deep dive on creating PHP SDKs using both Speakeasy and OpenAPI Generator, then we'll compare the generated SDKs.

## History of PHP OpenAPI generators

**OpenAPI Generator** is a community-run open-source tool for generating SDKs from OpenAPI documents. The project is not connected to the OpenAPI Initiative at all, which has been the source of much confusion. The origin of this project was as a [fork of Swagger Codegen](https://openapi-generator.tech/docs/fork-qna). [Swagger CodeGen](https://swagger.io/tools/swagger-codegen) is a similar tool maintained by SmartBear.

Both OpenAPI Generator and Swagger Codegen have a history of slow updates and lack of support for the latest OpenAPI versions, with Swagger CodeGen [showing no sign of supporting OpenAPI v3.1](https://github.com/swagger-api/swagger-codegen/issues/12560), and OpenAPI Generator still only offering beta support for OpenAPI v3.1. Seeing as OpenAPI v3.2 has been out for months at time of writing, still having incomplete or entirely missing support for v3.1 shows a worrying lack of progress.

PHP version support has also been slow. Managing which PHP versions to support is difficult, but maintaining compatibility with new PHP versions is critical and something these projects have struggled with. The last mention of PHP in the Swagger Generator roadmap was "adding compatibility with PHP 8.1" in late 2022, which is rather concerning given we're on PHP 8.5 at time of writing.

OpenAPI Generator has been able to able to maintain compatibility with newer PHP versions (does not throw errors using it on the latest versions), but the minimum version is PHP 8.1 which lost security support end of 2025. There is always a tradeoff with supporting older versions to help users stuck on older versions, but the project has also been slow to take advantage of newer PHP 8.x features to simplify generated code and improve user experience in an increasingly type safe world.

[JanePHP](https://github.com/janephp/janephp) appeared on the scene as a dedicated PHP SDK generator with more focus on modern PHP features. Sadly it too [lacks support for OpenAPI v3.1](https://github.com/janephp/janephp/issues/759 ) and above, and [does not support enums](https://github.com/janephp/janephp/issues/615) natively.

This comparison will only focus on tools with OpenAPI v3.1 support, so JanePHP will not be included and neither will Swagger CodeGen.

## Preparing the SDK generators

OpenAPI Generator requires Java to run, so some folks prefer to wrap that in a Docker image to keep their workstation clean. Thankfully there's a few [alternative installs](https://openapi-generator.tech/docs/installation/) for OpenAPI Generator, including a [Homebrew package](https://openapi-generator.tech/docs/installation/#homebrew) for macOS users, [Scoop package](https://openapi-generator.tech/docs/installation/#scoop) for Windows users, and [an NPM wrapper](https://openapi-generator.tech/docs/installation/#npm).

```sh
# macOS
brew install openapi-generator

# Windows
scoop install scoop install openapi-generator-cli

# NPM
npm install @openapitools/openapi-generator-cli -g
```

To install the Speakeasy CLI follow the steps in the [Speakeasy Getting Started guide](/docs/speakeasy-reference/cli/getting-started). Again there are multiple installation options, with [Homebrew for macOS](https://www.speakeasy.com/docs/speakeasy-reference/cli/getting-started#homebrew-macos) or [Chocolatey](https://www.speakeasy.com/docs/speakeasy-reference/cli/getting-started#chocolatey-windows) for Windows users.

```sh
# macOS
brew install speakeasy-api/tap/speakeasy

# Windows
choco install speakeasy

# Other platforms
curl -fsSL https://go.speakeasy.com/cli-install.sh | sh
```

Speakeasy has a user interface component as it is a full SaaS platform, but account creation will happen as part of the quickstart process later.

Finally to work with these SDK generators we'll need an OpenAPI document. We'll use the [Train Travel API](https://raw.githubusercontent.com/bump-sh-examples/train-travel-api/main/openapi.yaml) from our friends at Bump.sh for demonstration purposes. Save the file as `openapi.yaml` in your working directory.

```sh
wget https://raw.githubusercontent.com/bump-sh-examples/train-travel-api/main/openapi.yaml -O openapi.yaml
```

## Validating OpenAPI

Before creating an SDK its a good idea to validate the OpenAPI documents. There are plenty of tools available to do that, but it's best to use the built-in validation functionality of the SDK generator to make sure it's not only valid, but will work well in that tool.

OpenAPI Generator and Speakeasy CLI can validate OpenAPI documents, so let's run the two and see how they compare. 

Seeing as the Train Travel API is a known valid document there won't be any errors or warnings to see, but we can quickly borrow a known broken file to see the output. 

```
wget https://github.com/Mermade/openapi3-examples/raw/refs/heads/master/3.0/fail/deprecated.yaml -O openapi.bad.yaml
```

To validate using OpenAPI Generator, run the following in the terminal:

```sh
openapi-generator-cli validate -i openapi.bad.yaml
```

Surprisingly OpenAPI Generator seems to think this file is ok, despite it existing purely to be used as an example of an invalid OpenAPI document.

```
Validating spec (https://github.com/Mermade/openapi3-examples/raw/refs/heads/master/3.0/fail/deprecated.yaml)
No validation issues detected.
```

The validation command in Speakeasy is pretty similar, but seeing as Speakeasy's `validate` command can validate multiple formats including [Arazzo](https://www.speakeasy.com/openapi/arazzo), it needs `validate openapi` to specify the format:

```sh
speakeasy validate openapi -s openapi.bad.yaml
```

Speakeasy correctly identifies the issues with the file, seeing 1 error, 1 warning, and 3 hints.

```
validation error: [line 8] validate-json-schema - OpenAPI document invalid: expected boolean, but got string - https://spec.openapis.org/oas/3.0/schema/2021-09-28#/definitions/Operation/properties/deprecated/type
```

An error like this is critical to catch before generating an SDK, as it could lead to runtime errors or unexpected behavior in the generated code, so make sure to fix any errors before proceeding. 

Warnings can also exist, but usually are not blockers. Many warnings are best practice suggestions, like missing `operationId`, which will make generated method names less readable.

```
validation warn: [line 7] operation-operationId - the `GET` operation does not contain an `operationId`
```

Hint messages are more minor suggestions, like missing descriptions on parameters, missing examples, all things that are technically optional but helpful for SDK users. For example, not defining at least one server URL in the OpenAPI means the SDK will not know where to send requests, unless configured manually.

```
• validation hint: [line 1] validate-servers - No servers found in document, either add servers to the document or set a baseServerUrl in the gen.yaml config file
• validation hint: [line 10] missing-examples - Missing example for parameter. Consider adding an example
• validation hint: [line 17] missing-error-response - An error response should be defined for all operations
```

The warnings and hints in that document are more like opinions than specifically something that's definitely going to be a problem, but it's worrying that OpenAPI Generator didn't catch the error.

## Creating the SDKs

Right, time to generate some code. Let's create one with OpenAPI Generator and one with Speakeasy, then compare the results.

### Creating an SDK with OpenAPI Generator

OpenAPI Generator includes three different PHP templates for SDK generation: `php`, `php-dt`, `php-nexgen`. We'll use the stable [`php` generator](https://openapi-generator.tech/docs/generators/php) as `php-dt` is a wrapper around a very niche [DataTransfer](https://github.com/Articus/DataTransfer) package, and `php-nextgen` has been in beta for a long time without making much progress.

To create an SDK from the OpenAPI document using OpenAPI Generator, run this command:

```sh
openapi-generator-cli generate -i openapi.yaml -g php -o og
```

OpenAPI Generator creates three folders inside the `./og/` output folder:

<Table
  columns={[
    { key: "folder", header: "Folder" },
    { key: "content", header: "Content" }
  ]}
  data={[
    { 
      folder: "`docs`", 
      content: "Documentation in `.md` files for each object." 
    },
    { 
      folder: "`lib`", 
      content: "PHP code to call the API on the server, includes a `Model` folder containing a file for each object in the schema and an `Api` folder containing a file for each tag in the schema. If you pass [parameters](https://openapi-generator.tech/docs/generators/php#config-options) to the build command, you can rename `Api`, for example, to `TrainTravelSdk`." 
    },
    { 
      folder: "`test`", 
      content: "Unit test stubs for all objects and operations. The test stubs are empty, leaving testing logic to the developer." 
    }
  ]}
/>

A warning from OpenAPI Generator in the terminal read:

```
OpenAPI 3.1 support is still in beta. To report an issue related to 3.1 spec, please kindly open an issue in the Github repo: https://github.com/openAPITools/openapi-generator.
```

The [OpenAPI Generator roadmap](https://openapi-generator.tech/docs/roadmap) hasn't been updated since late 2022 and does not mention PHP or OpenAPI at all, so the comparison will have to focus on the current state of the SDKs.

### Creating an SDK with Speakeasy

Next, create an SDK using the Speakeasy CLI with the command below.

```sh
speakeasy quickstart
```

During this process you'll be prompted to log in or create an account if you don't have one already. After logging in, you'll be asked a few questions about the SDK you want to create, where an interactive prompt will guide you through the process.

<Table
  columns={[
    { key: "folder", header: "Folder" },
    { key: "content", header: "Content" }
  ]}
  data={[
    { 
      folder: "`docs`", 
      content: "Documentation in `.md` files for each component, operation, and tag." 
    },
    { 
      folder: "`src`", 
      content: "PHP code to call the API server, containing a `Models` folder for each schema and operation in the OpenAPI document. The `src` folder also contains a `Utils` folder containing code for common functions, like security and date handling." 
    }
  ]}
/>

Unlike OpenAPI Generator, Speakeasy does not create test stubs. [Testing SDKs](https://www.speakeasy.com/docs/sdks/sdk-contract-testing) is performed on Speakeasy's generator instead of the shipped SDK, so sharing those unit tests for generated SDKs adds unnecessary complexity and dependencies.

## First API request with each SDK

Both SDKs have been created successfully, so let's try calling the API with each SDK to make sure they work as expected. Each README.md should have instructions on how to call the API, so we'll follow those instructions for each SDK.

### Calling the API server with the OpenAPI Generator SDK

Here's an example of calling the Train Travel API to get a list of stations using the OpenAPI Generator SDK. The example below assumes you have installed the SDK using Composer and have autoloading set up, as well as having Guzzle installed as a dependency.

```php
<?php 
require_once(__DIR__ . '/vendor/autoload.php');

use OpenAPI\Client as OGTrainTravelClient;

$config = OGTrainTravelClient\Configuration::getDefaultConfiguration()
  ->setHost('https://try.microcks.io/rest/Train+Travel+API/1.0.0') // Mock Server URL
  ->setAccessToken('some-access-token');

$apiInstance = new OGTrainTravelClient\Api\StationsApi(
    new GuzzleHttp\Client(),
    $config
);

try {
  $result = $apiInstance->getStations();
  
  echo 'OG Stations list:', PHP_EOL;

  foreach ($result->getData() as $station) {
    echo $station->getName() . "\n";
  }

} catch (Exception $e) {
  echo 'Exception when StationsApi->getStations: ', $e->getMessage(), PHP_EOL;
}
```

The OG SDK example is quite verbose, requiring setting up a configuration object, creating an API instance, and handling exceptions. The model objects also use getter methods to access properties found in the response. By default it uses exceptions to handle errors which some people prefer over checking response objects directly.

### Calling the API server with the Speakeasy SDK

Here's an example of calling the Train Travel API to get a list of stations using the Speakeasy SDK. The example below assumes you have installed the SDK using Composer and have autoloading set up.

```php
<?php

declare(strict_types=1);

require 'vendor/autoload.php';

use Speakeasy\TrainTravelSdk;
use Speakeasy\TrainTravelSdk\Models\Operations;

$sdk = TrainTravelSdk\TrainTravelSDK::builder()
  ->setSecurity('some-access-token')
  ->setServerIndex(0)
  ->build();

$request = new Operations\GetStationsRequest();

$response = $sdk->stations->list(
  request: $request
);

if ($response->twoHundredApplicationJsonObject !== null) {
  echo PHP_EOL, 'Speakeasy Stations list:', PHP_EOL;

  foreach ($response->twoHundredApplicationJsonObject->data as $station) {
      echo $station->name . "\n";
  }
} else {
  // handle unexpected response
  echo "nah mate";
}
```

The Speakeasy SDK example is more concise, using a builder pattern to create the SDK instance and directly accessing properties on the response object. The request and response handling is also more straightforward.


## Package structure

Let's compare the structure of the SDKs in terms of code volume and folder structure.

You can count the lines of code in the SDKs by running `cloc` for each (ignoring documentation and test folders):

```sh
cloc ./og/lib
cloc ./speakeasy/src
```

Below are the results for each SDK.

<Table
  columns={[
    { key: "project", header: "Project" },
    { key: "files", header: "Files" },
    { key: "blank", header: "Blank lines" },
    { key: "comment", header: "Comment lines" },
    { key: "code", header: "Code lines" }
  ]}
  data={[
    { 
      project: "OpenAPI Generator", 
      files: "35",
      blank: "1839",
      comment: "8182",
      code: "7752"
    },
    { 
      project: "Speakeasy", 
      files: "114",
      blank: "1352",
      comment: "2743",
      code: "4826"
    }
  ]}
/>

OpenAPI Generator generates fewer files but has significantly more lines of code, comments, and blank lines than the Speakeasy SDK. This indicates that OpenAPI Generator produces more verbose code, which can be harder to read and maintain.

The following commands output the files of each SDK.

```sh
tree ./og/lib
tree ./speakeasy/src
```

Below is the output for OpenAPI Generator.

```sh
├── Api
│  ├── BookingsApi.php
│  ├── PaymentsApi.php
│  ├── StationsApi.php
│  └── TripsApi.php
├── ApiException.php
├── Configuration.php
├── FormDataProcessor.php
├── HeaderSelector.php
├── Model
│  ├── BankAccount.php
│  ├── Booking.php
│  ├── BookingPayment.php
│  ├── BookingPaymentSource.php
│  ├── Card.php
│  ├── CreateBooking201Response.php
│  ├── CreateBookingPayment200Response.php
│  ├── GetBookings200Response.php
│  ├── GetBookings200Response1.php
│  ├── GetStations200Response.php
│  ├── GetStations200Response1.php
│  ├── GetStations200ResponseAllOfLinks.php
│  ├── GetTrips200Response.php
│  ├── GetTrips200Response1.php
│  ├── GetTrips200ResponseAllOfDataInner.php
│  ├── LinksBooking.php
│  ├── LinksDestination.php
│  ├── LinksOrigin.php
│  ├── LinksPagination.php
│  ├── LinksSelf.php
│  ├── ModelInterface.php
│  ├── NewBookingRequest.php
│  ├── Problem.php
│  ├── Station.php
│  ├── Trip.php
│  └── WrapperCollection.php
└── ObjectSerializer.php
```

The folder structure is simple and clear with nothing unexpected. Files are separated at the resource level (booking, trip, station) but there are also a lot of models for shared components like bank accounts, cards, and links. Then there are files like `GetStations200Response1` and `GetTrips200ResponseAllOfDataInner` that just seem like its having a very confusing time with something.

Below is the output for Speakeasy.

```sh
./speakeasy/src
├── Bookings.php
├── Models
│  ├── Components
│  │  ├── AccountType.php
│  │  ├── BankAccount.php
│  │  ├── Booking.php
│  │  ├── BookingInput.php
│  │  ├── BookingPayment.php
│  │  ├── Card.php
│  │  ├── Currency.php
│  │  ├── LinksBooking.php
│  │  ├── LinksSelf.php
│  │  ├── Security.php
│  │  ├── Station.php
│  │  └── Trip.php
│  ├── Errors
│  │  └── APIException.php
│  ├── Operations
│  │  ├── AccountType.php
│  │  ├── BankAccount.php
│  │  ├── Card.php
│  │  ├── CreateBookingPaymentRequest.php
│  │  ├── CreateBookingPaymentResponse.php
│  │  ├── CreateBookingPaymentResponseBody.php
│  │  ├── CreateBookingRawResponse.php
│  │  ├── CreateBookingRawResponseBody.php
│  │  ├── CreateBookingRawXMLResponseBody.php
│  │  ├── CreateBookingResponse.php
│  │  ├── CreateBookingResponseBody.php
│  │  ├── CreateBookingXMLResponseBody.php
│  │  ├── Currency.php
│  │  ├── Data.php
│  │  ├── DeleteBookingRequest.php
│  │  ├── DeleteBookingResponse.php
│  │  ├── GetBookingRequest.php
│  │  ├── GetBookingResponse.php
│  │  ├── GetBookingResponseBody.php
│  │  ├── GetBookingsLinks.php
│  │  ├── GetBookingsRequest.php
│  │  ├── GetBookingsResponse.php
│  │  ├── GetBookingsResponseBody.php
│  │  ├── GetBookingsXMLLinks.php
│  │  ├── GetBookingsXMLResponseBody.php
│  │  ├── GetBookingXMLResponseBody.php
│  │  ├── GetStationsLinks.php
│  │  ├── GetStationsRequest.php
│  │  ├── GetStationsResponse.php
│  │  ├── GetStationsResponseBody.php
│  │  ├── GetStationsXMLLinks.php
│  │  ├── GetStationsXMLResponseBody.php
│  │  ├── GetTripsLinks.php
│  │  ├── GetTripsRequest.php
│  │  ├── GetTripsResponse.php
│  │  ├── GetTripsResponseBody.php
│  │  ├── GetTripsXMLLinks.php
│  │  ├── GetTripsXMLResponseBody.php
│  │  └── Status.php
│  └── Webhooks
│      ├── Links.php
│      ├── NewBookingRequest.php
│      └── NewBookingResponse.php
├── Payments.php
├── SDKConfiguration.php
├── Stations.php
├── TrainTravelSDK.php
├── TrainTravelSDKBuilder.php
├── Trips.php
└── Utils
    ├── BigDecimalHandler.php
    ├── BigIntHandler.php
    ├── DateHandler.php
    ├── DateTimeHandler.php
    ├── DefaultRequest.php
    ├── DefaultResponse.php
    ├── DefaultStream.php
    ├── DefaultUri.php
    ├── EnumHandler.php
    ├── FormMetadata.php
    ├── Headers.php
    ├── JSON.php
    ├── MixedJSONHandler.php
    ├── MultipartMetadata.php
    ├── Options.php
    ├── ParamsMetadata.php
    ├── PathParameters.php
    ├── PhpDocTypeParser.php
    ├── QueryParameters.php
    ├── RequestBodies.php
    ├── RequestMetadata.php
    ├── Retry
    │  ├── PermanentError.php
    │  ├── RetryConfig.php
    │  ├── RetryConfigBackoff.php
    │  ├── RetryConfigNone.php
    │  ├── RetryStrategy.php
    │  ├── RetryUtils.php
    │  └── TemporaryError.php
    ├── Security.php
    ├── SecurityClient.php
    ├── SecurityMetadata.php
    ├── ServerDetails.php
    ├── SpeakeasyMetadata.php
    ├── UnionHandler.php
    └── Utils.php
```

The Speakeasy SDK has a more complex folder structure, with separate folders for models, operations, errors, and utilities. Each operation has its own set of request and response classes, which can make it easier to understand the API's functionality. It's also not been tripped up by any weird schema constructs for allOfs like OpenAPI Generator has, so this structure at least looks a lot cleaner from here.

## Code readability

We'll compare the SDKs in terms of code readability, focusing on the `BookingPayment` model first.

### OpenAPI Generator

The `BookingPayment` model generated by OpenAPI Generator inherits a `ModelInterface` and has a `container` property that holds the model's fields. The model's constructor can either take an associative array of field names and values or no arguments. Then, the model exposes getter and setter methods for each field.

Type mapping is presented as an associative array of field names and types as strings. The `BookingPayment` model has the following fields:

```php filename="og/lib/Model/BookingPayment.php"
  // ...
  protected static $openAPITypes = [
      'id' => 'string',
      'amount' => 'float',
      'currency' => 'string',
      'source' => '\OpenAPI\Client\Model\BookingPaymentSource',
      'status' => 'string'
  ];
  // ...
```

Overall, the `BookingPayment` model is extremely verbose, coming in at 630 lines of code, including comments and whitespace, but excluding dependencies.

Contrast this with the `BookingPayment` model generated by Speakeasy.

### Speakeasy

The `BookingPayment` model generated by Speakeasy is more concise and readable, presented in its entirety below:
```php filename="app/se/src/Models/Components/BookingPayment.php"
<?php

declare(strict_types=1);

namespace Speakeasy\TrainTravelSdk\Models\Components;

/** BookingPayment - A payment for a booking. */
class BookingPayment
{
    /**
     * Amount intended to be collected by this payment. A positive decimal figure describing the amount to be collected.
     *
     * @var ?float $amount
     */
    #[\Speakeasy\Serializer\Annotation\SerializedName('amount')]
    #[\Speakeasy\Serializer\Annotation\SkipWhenNull]
    public ?float $amount = null;

    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     *
     * @var ?Currency $currency
     */
    #[\Speakeasy\Serializer\Annotation\SerializedName('currency')]
    #[\Speakeasy\Serializer\Annotation\Type('\Speakeasy\TrainTravelSdk\Models\Components\Currency|null')]
    #[\Speakeasy\Serializer\Annotation\SkipWhenNull]
    public ?Currency $currency = null;

    /**
     * The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
     *
     * @var Card|BankAccount|null $source
     */
    #[\Speakeasy\Serializer\Annotation\SerializedName('source')]
    #[\Speakeasy\Serializer\Annotation\Type('\Speakeasy\TrainTravelSdk\Models\Components\Card|\Speakeasy\TrainTravelSdk\Models\Components\BankAccount|null')]
    #[\Speakeasy\Serializer\Annotation\SkipWhenNull]
    public Card|BankAccount|null $source = null;

    /**
     * @param  ?float  $amount
     * @param  ?Currency  $currency
     * @param  Card|BankAccount|null  $source
     * @phpstan-pure
     */
    public function __construct(?float $amount = null, ?Currency $currency = null, Card|BankAccount|null $source = null)
    {
        $this->amount = $amount;
        $this->currency = $currency;
        $this->source = $source;
    }
}
```

The `BookingPayment` model, at 56 lines of code, including comments and whitespace, is more concise and readable than the `BookingPayment` model generated by OpenAPI Generator. Speakeasy uses modern PHP features like typed properties, enums, attributes, and named arguments to make the model more readable.

Serialization and deserialization are handled by [JMS/Serializer](http://jmsyst.com/libs/serializer), which uses annotations in the model to convert objects to and from JSON. This allows Speakeasy to create more concise and readable code.

Instead of using a getter and setter for each field, Speakeasy uses typed properties and a constructor to set the fields. This makes implementing the model more straightforward and less verbose.

## Dependencies

The OpenAPI Generator SDK Composer file has the dependencies below.

- The ext-curl, ext-json, and ext-mbstring PHP extensions, which handle calling HTTP, serialize objects to JSON, and work with Unicode.
- [Guzzle](https://docs.guzzlephp.org/en/stable) and [Guzzle PSR-7](https://github.com/guzzle/psr7) send HTTP requests with [PSR-7](https://www.php-fig.org/psr/psr-7/) support.
- [PHPUnit](https://phpunit.de/documentation.html) runs tests.
- [Symfony PHP Coding Standards Fixer](https://cs.symfony.com/) formats code.

The Speakeasy SDK Composer file has the dependencies below.

- [Guzzle](https://docs.guzzlephp.org/en/stable) sends HTTP requests.
- [Serializer](https://jmsyst.com/libs/serializer) converts PHP objects to and from JSON and XML to be sent over HTTP.
- [Brick\DateTime](https://github.com/brick/date-time) manages dates, times, and time zones.
- [phpDocumentor TypeResolver](https://github.com/phpDocumentor/TypeResolver) generates types from DocBlocks.
- [Laravel Pint](https://laravel.com/docs/11.x/pint) formats code.
- [PHPStan](https://phpstan.org/) finds errors and handles complex types.
- [PHPUnit](https://phpunit.de/documentation.html) runs tests. However, there are no tests in the created SDK.
- [Rector](https://github.com/rectorphp/rector) checks code quality.
- [Roave Security Advisories](https://github.com/Roave/SecurityAdvisories) warns about dangerous Composer dependencies.

Both creators use similar libraries, but OpenAPI Generator relies as much as possible on core PHP extensions, while Speakeasy has more serialization and complex typing libraries: Serializer, Brick, TypeResolver, and PHPStan.

## Supported PHP versions

At the time of compiling this comparison, the Speakeasy SDK required at least PHP 8.2, and the OpenAPI Generator SDK still supports PHP 8.1.

Seeing as PHP 8.1 has stopped receiving security updates we recommend updating to use the latest PHP version regardless of the SDK being used, but when the SDK is being used by external customers it's important to consider the lowest PHP version supported.

## Type system

Both tools create DocBlocks to provide type annotations to all parameters and variables in the SDKs, which is useful for IDEs and for programmers to understand the code.

But files in the Speakeasy SDK include the line `declare(strict_types=1);`, which causes PHP to throw a `TypeError` if a function accepts or returns an invalid type at runtime. The OpenAPI Generator SDK files do not have this line and so don't check types at runtime.

In Speakeasy, the JMS Serializer checks types when converting from JSON to PHP objects at runtime. OpenAPI Generator doesn't have this in plain Guzzle.

### Enums

By leveraging modern enum functionality in PHP 8.x, Speakeasy is able to bypass a lot of boilerplate code and allow PHP to optimize itself efficiently. For example, the Train Travel API has a currency enumeration defined inside booking payments that looks like this in OpenAPI:

```yaml
currency:
  description: Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
  type: string
  enum:
    - bam
    - bgn
    - chf
    - eur
    - gbp
```

The PHP to handle this in Speakeasy is straightforward using `enum`:

```php
<?php

namespace Speakeasy\TrainTravelSdk\Models\Components;

/** Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. */
enum Currency: string
{
    case Bam = 'bam';
    case Bgn = 'bgn';
    case Chf = 'chf';
    case Eur = 'eur';
    case Gbp = 'gbp';
}
```

Then the `BookingPayment` model can use the `Currency` enum as a typed property, ensuring only valid currency values are used.

```php
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     *
     * @var ?Currency $currency
     */
    public ?Currency $currency = null;
```

OpenAPI Generator is still stuck in ways of PHP from yesteryear, using workarounds from a pre-enum era with awkward constant strings and getter setter functions and lots of `in_array()` checks. Below is the same currency implementation in OpenAPI Generator.

```php
<?php

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

class BookingPayment implements ModelInterface, ArrayAccess, \JsonSerializable
{
  // ...
  
  public const CURRENCY_BAM = 'bam';
  public const CURRENCY_BGN = 'bgn';
  public const CURRENCY_CHF = 'chf';
  public const CURRENCY_EUR = 'eur';
  public const CURRENCY_GBP = 'gbp';

  /**
   * Gets allowable values of the enum
   *
   * @return string[]
   */
  public function getCurrencyAllowableValues()
  {
      return [
          self::CURRENCY_BAM,
          self::CURRENCY_BGN,
          self::CURRENCY_CHF,
          self::CURRENCY_EUR,
          self::CURRENCY_GBP,
      ];
  }

  // ...

  public function __construct(?array $data = null)
  {
      $this->setIfExists('id', $data ?? [], null);
      $this->setIfExists('amount', $data ?? [], null);
      $this->setIfExists('currency', $data ?? [], null);
      $this->setIfExists('source', $data ?? [], null);
      $this->setIfExists('status', $data ?? [], null);
  }
}
```

You can see how much more verbose and complex the OpenAPI Generator code is compared to Speakeasy's use of enums.

### Unions

In OpenAPI, you can use `oneOf` in a schema like this:

```yaml
User:
  type: object
  properties:
    age:
      oneOf:
        - type: integer
        - type: string
```

The `age` property will be typed as a union in PHP in Speakeasy:

```php
class User
{
  /**
   *
   * @var int|string|null $age
   */
  #[SpeakeasyMetadata('form:name=age')]
  public int|string|null $age = null;

  // ...

  public function __construct(?string $name = null, int|string|null $age = null)
```

OpenAPI Generator can handle this schema, but creates a 380-line file called `UserAge.php` with custom code to implement unions.

## Asynchronous calls

Both Speakeasy and OpenAPI Generator support asynchronous HTTP calls, but they implement them differently.

Speakeasy: `getStation` and `getStationAsync`.
OpenAPI Generator `AddPet` and `AddPetAsync`.

## Content types

Below are the content types in the schema for creating a booking, in JSON, XML, or as a form.

```yaml
requestBody:
  content:
    application/json:
      schema:
        $ref: "#/components/schemas/Booking"
    application/xml:
      schema:
        $ref: "#/components/schemas/Booking"
    application/x-www-form-urlencoded:
      schema:
        $ref: "#/components/schemas/Booking"
```

Speakeasy supports JSON and form content types, but not XML. OpenAPI Generator supports all three. 

In Speakeasy, each content type for each operation will become its own file in the SDK. In OpenAPI Generator, all operations are combined into one API file.

## Created documentation

Both Speakeasy and OpenAPI Generator create a `docs` directory with Markdown documentation and PHP usage examples for every operation and every model. Unfortunately despite the formatting not looking to great to the eye of the beholder, there are two syntax errors in here which will need to be fixed before trying to run this code. Can you spot them?

```php filename="og/docs/PaymentsApi.md"
<?php
require_once(__DIR__ . '/vendor/autoload.php');


// Configure OAuth2 access token for authorization: OAuth2
$config = OpenAPI\Client\Configuration::getDefaultConfiguration()->setAccessToken('YOUR_ACCESS_TOKEN');


$apiInstance = new OpenAPI\Client\Api\PaymentsApi(
    // If you want use custom http client, pass your client which implements `GuzzleHttp\ClientInterface`.
    // This is optional, `GuzzleHttp\Client` will be used as default.
    new GuzzleHttp\Client(),
    $config
);
$booking_id = 1725ff48-ab45-4bb5-9d02-88745177dedb; // string | The ID of the booking to pay for.
$booking_payment = {"amount":49.99,"currency":"gbp","source":{"object":"card","name":"J. Doe","number":"4242424242424242","cvc":"123","exp_month":12,"exp_year":2025,"address_line1":"123 Fake Street","address_line2":"4th Floor","address_city":"London","address_country":"gb","address_post_code":"N12 9XX"}}; // \OpenAPI\Client\Model\BookingPayment | Payment details

try {
    $result = $apiInstance->createBookingPayment($booking_id, $booking_payment);
    print_r($result);
} catch (Exception $e) {
    echo 'Exception when calling PaymentsApi->createBookingPayment: ', $e->getMessage(), PHP_EOL;
}
```

The code `$booking_id = 1725ff48-ab45-4bb5-9d02-88745177dedb;` is missing quotation marks around the string value, and the line `$booking_payment = {"amount":49.99,"currency":"gbp","source":{...}};` is using JSON syntax instead of PHP array or object syntax. Those `{}` curly braces need to be replaced with `[]` because PHP does not support JSON syntax for array or object literals.

The Speakeasy documentation example for the same operation is below:

```php filename="speakeasy/docs/sdks/payments/README.md"
declare(strict_types=1);

require 'vendor/autoload.php';

use Speakeasy\TrainTravelSdk;
use Speakeasy\TrainTravelSdk\Models\Components;

$sdk = TrainTravelSdk\TrainTravelSDK::builder()
    ->setSecurity(
        '<YOUR_O_AUTH2_HERE>'
    )
    ->build();

$body = new Components\BookingPayment(
    amount: 49.99,
    currency: Components\Currency::Gbp,
    source: new Components\Card(
        name: 'J. Doe',
        number: '4242424242424242',
        cvc: '123',
        expMonth: 12,
        expYear: 2025,
        addressLine1: '123 Fake Street',
        addressLine2: '4th Floor',
        addressCity: 'London',
        addressCountry: 'gb',
        addressPostCode: 'N12 9XX',
    ),
);

$response = $sdk->bookings->payments->create(
    bookingId: '1725ff48-ab45-4bb5-9d02-88745177dedb',
    body: $body

);

if ($response->object !== null) {
    // handle response
}
```

Instead of using associative arrays or awkwardly invalid JSON syntax, Speakeasy uses typed objects and named arguments to create the request body, making it more readable and less error-prone.

## Automation

This comparison focuses on installing and using Speakeasy and OpenAPI Generator using the command line, but both tools can also run as part of a CI workflow. For example, you can set up a [GitHub Action](https://github.com/speakeasy-api/sdk-generation-action) to ensure your Speakeasy SDK is always up-to-date when OpenAPI documents change.

OpenAPI Generator can run in any CI environment that supports Java, as it is a Java-based tool, but the generated SDKs come with a `travis-ci.yaml` which you'll need to delete or convert to another platform like GitHub Actions, as Travis CI is no longer widely used.

## Unsupported features

At the time of writing, OpenAPI Generator does not support:

- [Data types null, UUID](https://openapi-generator.tech/docs/generators/php/#data-type-feature), [all, any, and union](https://openapi-generator.tech/docs/generators/php/#schema-support-feature).
- [Server URLs with parameters](https://openapi-generator.tech/docs/generators/php/#global-feature).
- [Callbacks](https://openapi-generator.tech/docs/generators/php/#global-feature) (allowing your server to call a client).
- [Link objects](https://openapi-generator.tech/docs/generators/php/#global-feature) (relating operations to each other to indicate a workflow).

Neither service supports OAuth 2 flows other than Implicit.

## Summary

Open-source tooling can be a great way to experiment, but if you're working on production code, the Speakeasy PHP SDK creator will help ensure that you create reliable and performant PHP SDKs. The Speakeasy PHP SDK creator uses strong typing to provide safe runtime performance, supports many OpenAPI features, and is rapidly adding more.
