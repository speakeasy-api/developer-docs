---
title: "Using the Functions Framework"
description: "Learn how to use Gram's Functions Framework with TypeScript, including context objects and best practices."
---

## Overview

The Gram Functions Framework provides a streamlined way to build MCP tools using TypeScript. It handles the MCP protocol implementation while letting you focus on your tool logic.

![Choosing the Gram Framework](/assets/docs/gram/img/functions/npm_gram-framework.png)

## Function structure

Every Gram Function follows this basic structure:

```typescript filename="gram.ts"
import { Gram } from "@gram-ai/functions";
import * as z from "zod/mini";

const gram = new Gram().tool({
  name: "add",
  description: "Add two numbers together",
  inputSchema: { a: z.number(), b: z.number() },
  async execute(ctx, input) {
    return ctx.json({sum: input.a + input.b});
  },
});

export default gram;
```

## Tool definition

Each tool requires the following properties:

- **name**: Unique identifier for the tool
- **description** (optional): Human-readable explanation of what the tool does
- **inputSchema**: Zod schema defining the expected input parameters
- **execute**: Async function that implements the tool logic

## Context object

The execute function receives a context object with several helper methods for handling responses and accessing configuration:

### Response methods

- **ctx.json(data)**: Returns a JSON response
- **ctx.text(data)**: Returns a plain text response
- **ctx.html(data)**: Returns an HTML response
- **ctx.fail(data, options?)**: Throws an error response

```typescript
const gram = new Gram().tool({
  name: "format_data",
  inputSchema: { format: z.enum(["json", "text", "html"]), data: z.string() },
  async execute(ctx, input) {
    if (input.format === "json") {
      return ctx.json({ data: input.data });
    } else if (input.format === "text") {
      return ctx.text(input.data);
    } else {
      return ctx.html(`<div>${input.data}</div>`);
    }
  },
});
```

### Additional context properties

- **ctx.signal**: AbortSignal for handling cancellation
- **ctx.env**: Access to parsed environment variables

```typescript
const gram = new Gram().tool({
  name: "long_running_task",
  inputSchema: { url: z.string() },
  async execute(ctx, input) {
    try {
      const response = await fetch(input.url, { signal: ctx.signal });
      return ctx.json(await response.json());
    } catch (error) {
      if (error.name === "AbortError") {
        return ctx.fail("Request was cancelled");
      }
      throw error;
    }
  },
});
```

## Input validation

The framework validates inputs against the provided Zod schema by default. For strict validation, inputs that don't match the schema will be rejected.

### Lax mode

To allow unvalidated inputs, enable lax mode:

```typescript
const gram = new Gram({ lax: true }).tool({
  name: "flexible_tool",
  inputSchema: { required: z.string() },
  async execute(ctx, input) {
    // input may contain additional properties not in the schema
    return ctx.json({ received: input });
  },
});
```

## Environment variables

Specify credentials or environment variable values that need to be provided to the tool runner. These can be provided either by end user set MCP headers or with stored Gram environments.

```typescript
const gram = new Gram({
  envSchema: {
    API_KEY: z.string().describe("API key for authentication"),
    BASE_URL: z.string().url().describe("Base URL for API requests"),
  },
}).tool({
  name: "api_call",
  inputSchema: { endpoint: z.string() },
  async execute(ctx, input) {
    const apiKey = ctx.env?.["API_KEY"];
    const baseURL = ctx.env?.["BASE_URL"];

    const response = await fetch(`${baseURL}${input.endpoint}`, {
      headers: { Authorization: `Bearer ${apiKey}` },
    });

    return ctx.json(await response.json());
  },
});
```

For testing purposes, environment variables can be overridden via the `env` parameter. Otherwise, they default to `process.env`.

## Using fetch

Tools can make requests to downstream APIs and respond with the result:

```typescript
const gram = new Gram().tool({
  name: "spacex-ships",
  description: "Get the latest SpaceX ship list",
  inputSchema: {},
  async execute(ctx) {
    const response = await fetch("https://api.spacexdata.com/v3/ships");
    return ctx.json(await response.json());
  },
});
```

## Response flexibility

Tools can return responses in multiple formats:

- JSON responses via `ctx.json()`
- Plain text via `ctx.text()`
- HTML content via `ctx.html()`
- Custom Web API Response objects with specific headers and status codes

```typescript
const gram = new Gram().tool({
  name: "custom_response",
  inputSchema: { code: z.number() },
  async execute(ctx, input) {
    return new Response("Custom response", {
      status: input.code,
      headers: { "X-Custom-Header": "value" },
    });
  },
});
```

## Next steps
- [Build and deploy](/docs/gram/gram-functions/build-deploy)